## 2020-07-25

## 浏览器工作原理与实践

### Chrome架构：仅仅打开一个页面，为什么有4个进程

点击Chrome浏览器右上⻆的“选项”菜单，选择“更多⼯具”⼦菜单，点击“任务管理器”，将打开Chrome的任务管理器的窗口

#### 进程和线程

`并⾏处理`

计算机中的并⾏处理就是同⼀时刻处理多个任务，使⽤并⾏处理能⼤⼤提升性能。

`线程 VS 进程`

⼀个进程就是⼀个程序的运⾏实例。详细解释就是，启动⼀个程序的时候，操作系统会为该程序创建⼀块内
存，⽤来存放代码、运⾏中的数据和⼀个执⾏任务的主线程，我们把这样的⼀个运⾏环境叫进程。

而线程是不能单独存在的，它是由进程来启动和管理的。

线程是依附于进程的，⽽进程中使⽤多线程并⾏处理能提升运算效率。

进程和线程之间的关系有以下4个特点：
- 进程中的任意⼀线程执⾏出错，都会导致整个进程的崩溃
- 线程之间共享进程中的数据
- 当⼀个进程关闭之后，操作系统会回收进程所占⽤的内存
- 进程之间的内容相互隔离
  - 进程隔离是为保护操作系统中进程互不⼲扰的技术，每⼀个进程只能访问⾃⼰占有的数据，也就避免出现进
程A写⼊数据到进程B的情况。
  - 正是因为进程之间的数据是严格隔离的，所以⼀个进程如果崩溃了，或者挂
起了，是不会影响到其他进程的。
  - 如果进程之间需要进⾏数据的通信，这时候，就需要使⽤⽤于进程间通信
（IPC）的机制了。

`单进程浏览器时代`

- 问题1：不稳定，⼀些复杂的JavaScript代码就有可能引起渲染引擎模块的
崩溃。和插件⼀样，渲染引擎的崩溃也会导致整个浏览器的崩溃。
- 问题2：不流畅，同⼀时刻只能有⼀个模块可以执⾏以及⻚⾯的内存泄漏
- 问题3：不安全

`多进程架构`

最新的Chrome浏览器包括：1个浏览器（Browser）主进程、1个 GPU 进程、1个⽹络
（NetWork）进程、多个渲染进程和多个插件进程。

- 浏览器进程。主要负责界⾯显⽰、⽤⼾交互、⼦进程管理，同时提供存储等功能。
- 渲染进程。核⼼任务是将 HTML、CSS 和 JavaScript 转换为⽤⼾可以与之交互的⽹⻚，排版引擎Blink和
JavaScript引擎V8都是运⾏在该进程中，默认情况下，Chrome会为每个Tab标签创建⼀个渲染进程。出
于安全考虑，渲染进程都是运⾏在沙箱模式下。
- GPU进程。其实，Chrome刚开始发布的时候是没有GPU进程的。⽽GPU的使⽤初衷是为了实现3D CSS的
效果，只是随后⽹⻚、Chrome的UI界⾯都选择采⽤GPU来绘制，这使得GPU成为浏览器普遍的需求。最
后，Chrome在其多进程架构上也引⼊了GPU进程。
- ⽹络进程。主要负责⻚⾯的⽹络资源加载，之前是作为⼀个模块运⾏在浏览器进程⾥⾯的，直⾄最近才独
⽴出来，成为⼀个单独的进程。
- 插件进程。主要是负责插件的运⾏，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃
不会对浏览器和⻚⾯造成影响。

`未来⾯向服务的架构`

“⾯向服务的架构”（Services OrientedArchitecture，简称SOA）。原来的各种模块会被重构成独⽴的服务（Service），每个服务（Service）都可以在独⽴的进程中运⾏，访问服务（Service）必须使⽤定义好的接⼝，通过IPC来通信，从⽽构建⼀个更内聚、松耦合、易于维护和扩展的系统，更好实现 Chrome 简单、稳定、⾼速、安全的⽬标。

### 第二章 TCP协议：如何保证⻚⾯⽂件能被完整送达浏览器？

在衡量Web⻚⾯性能的时候有⼀个重要的指标叫“FP（First Paint）”，是指从⻚⾯加载到⾸次开始绘制
的时⻓。影响FP指标的其中⼀个重要的因素是⽹络加载速度。

>HTTP和WebSocket都是基于TCP/IP的。

互联⽹中的数据是通过数据包来传输的。如果发送的数据很⼤，那么该数据就会被拆分为很多⼩数据包来传
输。⽐如你现在听的⾳频数据，是拆分成⼀个个⼩的数据包来传输的，并不是⼀个⼤的⽂件⼀次传输过来
的。

`IP：把数据包送达⽬的主机`

数据包要在互联⽹上进⾏传输，就要符合⽹际协议（Internet Protocol，简称IP）标准。

计算机的地址就称为IP地址，访问任何⽹站实际上只是你的计算机向另外⼀台计算机请求信息。

如果要想把⼀个数据包从主机A发送给主机B，那么在传输之前，数据包上会被附加上主机B的IP地址信息，
这样在传输过程中才能正确寻址。额外地，数据包上还会附加上主机A本⾝的IP地址，有了这些信息主机B
才可以回复信息给主机A。这些附加的信息会被装进⼀个叫IP头的数据结构⾥。IP头是IP数据包开头的信
息，包含IP版本、源IP地址、⽬标IP地址、⽣存时间等信息。

`UDP：把数据包送达应⽤程序`

IP是⾮常底层的协议，只负责把数据包传送到对⽅电脑，因此，需要基于IP之上开发能和应⽤打交道的协议，最常⻅的是“⽤⼾数据包协议（User Datagram Protocol）”，简称UDP。

UDP中⼀个最重要的信息是端⼝号，端⼝号其实就是⼀个数字，每个想访问⽹络的程序都需要绑定⼀个端⼝
号。通过端⼝号UDP就能把指定的数据包发送给指定的程序了，所以IP通过IP地址信息把数据包发送给指定
的电脑，⽽UDP通过端⼝号把数据包分发给正确的程序。和IP头⼀样，端⼝号会被装进UDP头⾥⾯，UDP头
再和原始数据包合并组成新的UDP数据包。UDP头中除了⽬的端⼝，还有源端⼝号等信息。

>在使⽤UDP发送数据时，有各种因素会导致数据包出错，虽然UDP可以校验数据是否正确，但是对于错误的数据包，UDP并不提供重发机制，只是丢弃当前的包，⽽且UDP在发送之后也⽆法知道是否能达到⽬的地。

>UDP不能保证数据可靠性，但是传输速度却⾮常快，所以UDP会应⽤在⼀些关注速度、但不那么严格要求数据完整性的领域，如在线视频、互动游戏等。

`TCP：把数据完整地送达应⽤程序`

对于浏览器请求，或者邮件这类要求数据传输可靠性（reliability）的应⽤，如果使⽤UDP来传输会存在两
个问题：
- 数据包在传输过程中容易丢失；
- ⼤⽂件会被拆分成很多⼩的数据包来传输，这些⼩的数据包会经过不同的路由，并在不同的时间到达接收
端，⽽UDP协议并不知道如何组装这些数据包，从⽽把这些数据包还原成完整的⽂件。

TCP（Transmission Control Protocol，传输控制协议）是⼀种⾯向
连接的、可靠的、基于字节流的传输层通信协议。相对于UDP，TCP有下⾯两个特点:
- 对于数据包丢失的情况，TCP提供重传机制；
- TCP引⼊了数据包排序机制，⽤来保证把乱序的数据包组合成⼀个完整的⽂件。

⼀个完整的TCP连接的⽣命周期包括了“**建⽴连接**”“**传输数据**”和“**断开连接**”三个阶
段。
- ⾸先，建⽴连接阶段。这个阶段是通过“三次握⼿”来建⽴客⼾端和服务器之间的连接。TCP 提供⾯向连
接的通信传输。⾯向连接是指在数据通信开始之前先做好两端之间的准备⼯作。**所谓三次握⼿，是指在建
⽴⼀个TCP连接时，客⼾端和服务器总共要发送三个数据包以确认连接的建⽴**。

- 其次，传输数据阶段。在该阶段，接收端需要对每个数据包进⾏确认操作，也就是接收端在接收到数据包
之后，需要发送确认数据包给发送端。所以当发送端发送了⼀个数据包之后，在规定时间内没有接收到接
收端反馈的确认消息，则判断为数据包丢失，并触发发送端的重发机制。同样，⼀个⼤的⽂件在传输过程
中会被拆分成很多⼩的数据包，这些数据包到达接收端后，接收端会按照TCP头中的序号为其排序，从⽽
保证组成完整的数据。

- 最后，断开连接阶段。数据传输完毕之后，就要终⽌连接了，涉及到最后⼀个阶段“四次挥⼿”来保证双
⽅都能断开连接。

>TCP为了保证数据传输的可靠性，牺牲了数据包的传输速度，因为“三次握⼿”和“数据包校验机制”等把传输过程中的数据包的数量提⾼了⼀倍。


### 第三章 HTTP请求流程：为什么很多站点第⼆次打开速度会很快？

HTTP协议，正是建⽴在TCP连接基础之上的。HTTP是⼀种允许浏览器向服务器获取资源的协议，是
Web的基础，通常由浏览器发起请求，⽤来获取不同类型的⽂件，例如HTML⽂件、CSS⽂件、JavaScript
⽂件、图⽚、视频等。此外，HTTP也是浏览器使⽤最⼴的协议。

`浏览器端发起HTTP请求流程`
- 构建请求

  浏览器构建请求⾏信息（如下所⽰），构建好后，浏览器准备发起⽹络请求。

  ```
  GET /index.html HTTP1.1
  ```

- 查找缓存

  在真正发起⽹络请求之前，浏览器会先在浏览器缓存中查询是否有要请求的⽂件。其中，浏览器缓存是⼀种在本地保存资源副本，以供下次请求时直接使⽤的技术。

  当浏览器发现请求的资源已经在浏览器缓存中存有副本，它会拦截请求，返回该资源的副本，并直接结束请求，⽽不会再去源服务器重新下载。

- 准备IP地址和端⼝

  浏览器使⽤HTTP协议作为应⽤层协议，⽤来封装请求的⽂本信息；并使⽤TCP/IP作传输层协议将它发到⽹络上，所以在HTTP⼯作开始之前，浏览器需要通过TCP与服务器建⽴连接。也就是说HTTP的内容是通过TCP的传输数据阶段来实现的

  数据包都是通过IP地址传输给接收⽅的。由于IP地址是数字标识，⽐如极客时
  间⽹站的IP是39.106.233.176, 难以记忆，但使⽤极客时间的域名（time.geekbang.org）就好记多了，所以
  基于这个需求⼜出现了⼀个服务，负责把域名和IP地址做⼀⼀映射关系。这套域名映射为IP的系统就叫
  做“域名系统”，简称DNS（Domain Name System）。

  第⼀步浏览器会请求DNS返回域名对应的IP。当然浏览器还提供了DNS数据缓存服务，如果某个域名已经解析过了，那么浏览器会缓存解析的结果，以供下次查询时直接使⽤，这样也会减少⼀次⽹络请求。

  拿到IP之后，接下来就需要获取端⼝号了。通常情况下，如果URL没有特别指明端⼝号，那么HTTP协议默
  认是80端⼝。

- 等待TCP队列
- 建⽴TCP连接
- 发送HTTP请求

  ⼀旦建⽴了TCP连接，浏览器就可以和服务器进⾏通信了。⽽HTTP中的数据正是在这个通信过程中传输的。

  ⾸先浏览器会向服务器发送请求⾏，它包括了请求⽅法、请求URI（Uniform Resource Identifier）和
HTTP版本协议。

`服务器端处理HTTP请求流程`
- 返回请求

  curl来查看返回请求数据，具体使⽤⽅法是在命令⾏中输⼊以下命令：
  ```
  curl -i https://time.geekbang.org/
  ```
- 断开连接

  通常情况下，⼀旦服务器向客⼾端返回了请求数据，它就要关闭 TCP 连接。不过如果浏览器或者服务器在其头信息中加⼊了：

  ```
  Connection:Keep-Alive
  ```

- 重定向


### 第四章 导航流程：从输⼊URL到⻚⾯展⽰，这中间发⽣了什么？

从输⼊URL到⻚⾯展⽰，整个过程需要各个进程之间的配合

浏览器进程、渲染进程和⽹络进程的主要职责：
- 浏览器进程主要负责⽤⼾交互、⼦进程管理和⽂件储存等功能。
- ⽹络进程是⾯向渲染进程和浏览器进程等提供⽹络下载功能。
- 渲染进程的主要职责是把从⽹络下载的HTML、JavaScript、CSS、图⽚等资源解析为可以显⽰和交互的
⻚⾯。因为渲染进程所有的内容都是通过⽹络获取的，会存在⼀些恶意代码利⽤浏览器漏洞对系统进⾏攻
击，所以运⾏在渲染进程⾥⾯的代码是不被信任的。这也是为什么Chrome会让渲染进程运⾏在安全沙箱
⾥，就是为了保证系统的安全。


从输⼊URL到⻚⾯展⽰过程可以⼤致描述为如下：
- ⾸先，⽤⼾从浏览器进程⾥输⼊请求信息；
- 然后，⽹络进程发起URL请求；
- 服务器响应URL请求之后，浏览器进程就⼜要开始准备渲染进程了；
- 渲染进程准备好之后，需要先向渲染进程提交⻚⾯数据，我们称之为提交⽂档阶段；
- 渲染进程接收完⽂档信息之后，便开始解析⻚⾯和加载⼦资源，完成⻚⾯的渲染。

>⽤⼾发出URL请求到⻚⾯开始解析的这个过程，就叫做导航

`从输⼊URL到⻚⾯展⽰`

- ⽤⼾输⼊
- URL请求过程

  - 浏览器进程会通过进程间通信（IPC）把URL请求发送⾄⽹络进程，⽹络进程接收到URL请求后，会在这⾥发起真正的URL请求流程。
  - ⽹络进程会查找本地缓存是否缓存了该资源。如果有缓存资源，那么直接返回资源给浏览器进程；如果在缓存中没有查找到资源，那么直接进⼊⽹络请求流程。这请求前的第⼀步是要进⾏DNS解析，以获取请求域名的服务器IP地址。如果请求协议是HTTPS，那么还需要建⽴TLS连接。
  - 利⽤IP地址和服务器建⽴TCP连接。连接建⽴之后，浏览器端会构建请求⾏、请求头等信息，并把和该域名相关的Cookie等数据附加到请求头中，然后向服务器发送构建的请求信息。
  - 服务器接收到请求信息后，会根据请求信息⽣成响应数据（包括响应⾏、响应头和响应体等信息），并发给⽹络进程。等⽹络进程接收了响应⾏和响应头之后，就开始解析响应头的内容了。

  注意：
  
  `1、重定向`

   在接收到服务器返回的响应头后，⽹络进程开始解析响应头，如果发现返回的状态码是301或者302，那么说明服务器需要浏览器重定向到其他URL。这时⽹络进程会从响应头的Location字段⾥⾯读取重定向的地址，然后再发起新的HTTP或者HTTPS请求，⼀切⼜重头开始了。

   在导航过程中，如果服务器响应⾏的状态码包含了301、302⼀类的跳转信息，浏览器会跳转到新的地址继续导航；如果响应⾏是200，那么表⽰浏览器可以继续处理该请求。

  `2.响应数据类型处理`

  Content-Type是HTTP头中⼀个⾮常重要的字段， 它告诉浏览器服务器返回的响应体数据是什么类型，然后浏览器会根据Content-Type的值来决定如何显⽰响应体的内容。

  如果Content-Type字段的值被浏览器判断为下载类型，那么该请求会被提交给浏览器的下载管理器，同时该URL请求的导航流程就此结束。但如果是HTML，那么浏览器则会继续进⾏导航流程。

- 准备渲染进程

  默认情况下，Chrome会为每个⻚⾯分配⼀个渲染进程。但如果从⼀个⻚⾯打开了另⼀个新⻚⾯，⽽新⻚⾯和当前⻚⾯属于同⼀站点的话，那么新⻚⾯会复⽤⽗⻚⾯的渲染进程

- 提交文档

  这⾥的“⽂档”是指URL请求的响应体数据。
  
  - “提交⽂档”的消息是由浏览器进程发出的，渲染进程接收到“提交⽂档”的消息后，会和⽹络进程建⽴
传输数据的“管道”。
  - 等⽂档数据传输完成之后，渲染进程会返回“确认提交”的消息给浏览器进程。
  - 浏览器进程在收到“确认提交”的消息后，会更新浏览器界⾯状态，包括了安全状态、地址栏的URL、前
进后退的历史状态，并更新Web⻚⾯。

- 渲染阶段

  ⼀旦⽂档被提交，渲染进程便开始⻚⾯解析和⼦资源加载了


### 第五章 渲染流程（上）：HTML、CSS和JavaScript，是如何变成⻚⾯的？

HTML的内容是由标记和⽂本组成。标记也称为标签，每个标签都有它⾃⼰的语意，浏览器会根据标签的语意来正确展⽰HTML内容。

CSS⼜称为层叠样式表，是由选择器和属性组成

JavaScript（简称为JS），使⽤它可以使⽹⻚的内容“动”起来


由于渲染机制过于复杂，所以渲染模块在执⾏过程中会被划分为很多⼦阶段，输⼊的HTML经过这些⼦阶段，最后输出像素。我们把这样的⼀个处理流程叫做渲染流⽔线。

按照渲染的时间顺序，流⽔线可分为如下⼏个⼦阶段：构建DOM树、样式计算、布局阶段、分层、绘制、分块、光栅化和合成。

每个阶段重点关注以下三点内容：
- 开始每个⼦阶段都有其输⼊的内容；
- 然后每个⼦阶段有其处理过程；
- 最终每个⼦阶段会⽣成输出内容。

`1、构建DOM树`

浏览器⽆法直接理解和使⽤HTML，所以需要将HTML转换为浏览器能够理解的结构——DOM树。

构建DOM树的输⼊内容是⼀个⾮常简单的HTML⽂件，然后经由HTML解析器解析，最终输出树状结构的DOM。

在浏览器console控制台⾥⾯输⼊“document”后回⻋，这样你就能看到⼀个完整的DOM树结构。

document就是DOM结构，你可以看到，DOM和HTML内容⼏乎是⼀样的，但是和HTML不同的是，DOM是保存在内存中树状结构，可以通过JavaScript来查询或修改其内容。

`2、样式计算（Recalculate Style）`

要让DOM节点拥有正确的样式，这就需要样式计算了。样式计算的⽬的是为了计算出DOM节点中每个元素的具体样式，这个阶段⼤体可分为三步来完成。
- 把CSS转换为浏览器能够理解的结构

  当渲染引擎接收到CSS⽂本时，会执⾏⼀个转换操作，将CSS⽂本转换为浏览器可以理解的结构——styleSheets。

  渲染引擎会把获取到的CSS⽂本全部转换为styleSheets结构中的数据，并且该结构同时具备了查询和修改功能，这会为后⾯的样式操作提供基础。

- 转换样式表中的属性值，使其标准化
- 计算出DOM树中每个节点的具体样式

  样式计算阶段的⽬的是为了计算出DOM节点中每个元素的具体样式，在计算过程中需要遵守CSS的继承和层叠两个规则。这个阶段最终输出的内容是每个DOM节点的样式，并被保存在ComputedStyle的结构内。

`3、布局阶段`

计算出DOM树中可⻅元素的⼏何位置，我们把这个计算过程叫做布局。
- 创建布局树

  遍历DOM树中的所有可⻅节点，并把这些节点加到布局中；⽽不可⻅的节点会被布局树忽略掉，如head标签下⾯的全部内容，再⽐如body.p.span这个元素，因为它的属性包含 dispaly:none，所以这个元素也没有被包进布局树。

- 布局计算

  有了⼀棵完整的布局树。那么接下来，就要计算布局树节点的坐标位置了。布局的计算过程⾮常复杂

  在执⾏布局操作的时候，会把布局运算的结果重新写回布局树中，所以布局树既是输⼊内容也是输出内容，这是布局阶段⼀个不合理的地⽅，因为在布局阶段并没有清晰地将输⼊内容和输出内容区分开来。

  Chrome团队正在重构布局代码，下⼀代布局系统叫LayoutNG，试图更清晰地分离输⼊和输出，从⽽让新设计的布局算法更加简单。

  ### 第六章 渲染流程（下）：HTML、CSS和JavaScript，是如何变成⻚⾯的？

  `分层`

  因为⻚⾯中有很多复杂的效果，如⼀些复杂的3D变换、⻚⾯滚动，或者使⽤z-indexing做z轴排序等，为了
更加⽅便地实现这些效果，渲染引擎还需要为特定的节点⽣成专⽤的图层，并⽣成⼀棵对应的图层树
（LayerTree）。如果你熟悉PS，相信你会很容易理解图层的概念，正是这些图层叠加在⼀起构成了最终的
⻚⾯图像。

并不是布局树的每个节点都包含⼀个图层，如果⼀个节点没有对应的层，那么这个节点就从属
于⽗节点的图层。

满足以下条件，渲染引擎会为特定的节点创建新的层：

- 拥有层叠上下⽂属性的元素会被提升为单独的⼀层

  明确定位属性的元素、定义透明属性的元素、使⽤CSS滤镜的元素等，都拥有层叠上下⽂
属性。

- 需要剪裁（clip）的地⽅也会被创建为图层

`图层绘制`

在完成图层树的构建之后，渲染引擎会对图层树中的每个图层进⾏绘制

`栅格化（raster）操作`

绘制列表只是⽤来记录绘制顺序和绘制指令的列表，⽽实际上绘制操作是由渲染引擎中的合成线程来完成
的。


通常⼀个⻚⾯可能很⼤，但是⽤⼾只能看到其中的⼀部分，我们把⽤⼾可以看到的这个部分叫做视⼝
（viewport）。

合成线程会按照视⼝附近的图块来优先⽣成位图，实际⽣成位图的操作是由栅格化来执⾏的。所谓栅格
化，是指将图块转换为位图。⽽图块是栅格化执⾏的最⼩单位。渲染进程维护了⼀个栅格化的线程池，所有
的图块栅格化都是在线程池内执⾏的，


栅格化过程都会使⽤GPU来加速⽣成，使⽤GPU⽣成位图的过程叫快速栅格化，或者GPU栅格化，⽣
成的位图被保存在GPU内存中。


`合成和显⽰`

⼀旦所有图块都被光栅化，合成线程就会⽣成⼀个绘制图块的命令⸺“DrawQuad”，然后将该命令提交
给浏览器进程。

浏览器进程⾥⾯有⼀个叫viz的组件，⽤来接收合成线程发过来的DrawQuad命令，然后根据DrawQuad命
令，将其⻚⾯内容绘制到内存中，最后再将内存显⽰在屏幕上。


`渲染流⽔线⼤总结`

- 渲染进程将HTML内容转换为能够读懂的DOM树结构。
- 渲染引擎将CSS样式表转化为浏览器可以理解的styleSheets，计算出DOM节点的样式。
- 创建布局树，并计算元素的布局信息。
- 对布局树进⾏分层，并⽣成分层树。
- 为每个图层⽣成绘制列表，并将其提交到合成线程。
- 合成线程将图层分成图块，并在光栅化线程池中将图块转换成位图。
- 合成线程发送绘制图块命令DrawQuad给浏览器进程。
- 浏览器进程根据DrawQuad消息⽣成⻚⾯，并显⽰到显⽰器上。

`更新了元素的⼏何属性（重排）`

通过JavaScript或者CSS修改元素的⼏何位置属性，例如改变元素的宽度、⾼度
等，那么浏览器会触发重新布局，解析之后的⼀系列⼦阶段，这个过程就叫重排。⽆疑，重排需要更新完整
的渲染流⽔线，所以开销也是最⼤的。

`更新元素的绘制属性（重绘）`

没有引起⼏何位置的变换，所以就直接进⼊了绘制阶段，然后执⾏之后的⼀系列⼦阶段，这个过程就叫重绘。相较于重排操作，重绘省去了布局和分层阶段，所以执⾏效率会⽐重排操作要⾼⼀些。


`直接合成阶段`

渲染引擎将跳过布局和绘制，只执⾏后续的合成操作，我们把这个过程叫做合成

使⽤了CSS的transform来实现动画效果，这可以避开重排和重绘阶段，直接在⾮主线程上
执⾏合成动画操作。这样的效率是最⾼的，因为是在⾮主线程上合成，并没有占⽤主线程的资源，另外也避
开了布局和绘制两个⼦阶段，所以相对于重绘和重排，合成能⼤⼤提升绘制效率。


### 第七章 变量提升：JavaScript代码是按顺序执⾏的吗？

`变量提升（Hoisting）`

所谓的变量提升，是指在JavaScript代码执⾏过程中，JavaScript引擎把变量的声明部分和函数的声明部
分提升到代码开头的“⾏为”。变量被提升后，会给变量设置默认值，这个默认值就是我们熟悉的
undefined。

函数和变量在执⾏之前都提升到了代码开头。

`JavaScript代码的执⾏流程`

实际上变量和函数声明在代码⾥的位置是不会改变的，⽽且是在编译阶段被JavaScript引擎放⼊内存中。

⼀段JavaScript代码在执⾏之前需要被JavaScript引擎编译，编译完成之后，才会进⼊执⾏阶段。

输⼊⼀段代码，经过编译后，会⽣成两部分内容：执⾏上下⽂（Execution context）和可执⾏代码。

执⾏上下⽂是JavaScript执⾏⼀段代码时的运⾏环境，⽐如调⽤⼀个函数，就会进⼊这个函数的执⾏上下
⽂，确定该函数在执⾏期间⽤到的诸如this、变量、对象以及函数等。

在执⾏上下⽂中存在⼀个变量环境的对象（Viriable Environment），该对象中保存了变量提升的内容，⽐如上⾯代码中的变量myname和函数showName，都保存在该对象中。

`如何⽣成变量环境对象的。`

```js
showName()
console.log(myname)
var myname = '极客时间'
function showName() {
console.log('函数showName被执⾏');
}
```
- 第1⾏和第2⾏，由于这两⾏代码不是声明操作，所以JavaScript引擎不会做任何处理；
- 第3⾏，由于这⾏是经过var声明的，因此JavaScript引擎将在环境对象中创建⼀个名为myname的属性，
并使⽤undefined对其初始化；
- 第4⾏，JavaScript引擎发现了⼀个通过function定义的函数，所以它将函数定义存储到堆(HEAP）中，
并在环境对象中创建⼀个showName的属性，然后将该属性值指向堆中函数的位置

这样就⽣成了变量环境对象。接下来JavaScript引擎会把声明以外的代码编译为字节

`执⾏阶段`

JavaScript引擎开始执⾏“可执⾏代码”，按照顺序⼀⾏⼀⾏地执⾏

`总结`

- JavaScript代码执⾏过程中，需要先做变量提升，⽽之所以需要实现变量提升，是因为JavaScript代码在
执⾏之前需要先编译。
- 在编译阶段，变量和函数会被存放到变量环境中，变量的默认值会被设置为undefined；在代码执⾏阶
段，JavaScript引擎会从变量环境中去查找⾃定义的变量和函数。
- 如果在编译阶段，存在两个相同的函数，那么最终存放在变量环境中的是最后定义的那个，这是因为后定
义的会覆盖掉之前定义的。


### 第八章 调⽤栈：为什么JavaScript代码会出现栈溢出？

符合以下规范的代码才会在执行之前就进行编译并创建执行上下文：

- 当JavaScript执⾏全局代码的时候，会编译全局代码并创建全局执⾏上下⽂，⽽且在整个⻚⾯的⽣存周期
内，全局执⾏上下⽂只有⼀份。
- 当调⽤⼀个函数的时候，函数体内的代码会被编译，并创建函数执⾏上下⽂，⼀般情况下，函数执⾏结
束之后，创建的函数执⾏上下⽂会被销毁。
- 当使⽤eval函数的时候，eval的代码也会被编译，并创建执⾏上下⽂。

调⽤栈就是⽤来管理函数调⽤关系的⼀种数据结构

`什么是函数调⽤`

```js
var a = 2
function add(){
var b = 10
return a+b
}
add()
```

执⾏上下⽂准备好之后，便开始执⾏全局代码，当执⾏到add这⼉时，JavaScript判断这是⼀个函数调⽤，
那么将执⾏以下操作：
- ⾸先，从全局执⾏上下⽂中，取出add函数代码。
- 其次，对add函数的这段代码进⾏编译，并创建该函数的执⾏上下⽂和可执⾏代码。
- 最后，执⾏代码，输出结果。


也就是说在执⾏JavaScript时，可能会存在多个执⾏上下⽂。这时候需要一种栈的数据结构来管理。


`什么是JavaScript的调⽤栈`

JavaScript引擎正是利⽤栈的这种结构来管理执⾏上下⽂的。在执⾏上下⽂创建好后，JavaScript引擎会将
执⾏上下⽂压⼊栈中，通常把这种⽤来管理执⾏上下⽂的栈称为执⾏上下⽂栈，⼜称调⽤栈。

调⽤栈是JavaScript引擎追踪函数执⾏的⼀个机制，当⼀次有多个函数被调⽤时，通过调⽤栈就能够追踪到哪个函数正在被执⾏以及各函数之间的调⽤关系。

`栈溢出（Stack Overflow）`

调⽤栈是⼀种⽤来管理执⾏上下⽂的数据结构，符合后进先出的规则。不过还有⼀点你要注
意，调⽤栈是有⼤⼩的，当⼊栈的执⾏上下⽂超过⼀定数⽬，JavaScript引擎就会报错，我们把这种错误叫
做栈溢出。

`总结`

- 每调⽤⼀个函数，JavaScript引擎会为其创建执⾏上下⽂，并把该执⾏上下⽂压⼊调⽤栈，然后
JavaScript引擎开始执⾏函数代码。
- 如果在⼀个函数A中调⽤了另外⼀个函数B，那么JavaScript引擎会为B函数创建执⾏上下⽂，并将B函数
的执⾏上下⽂压⼊栈顶。
- 当前函数执⾏完毕后，JavaScript引擎会将该函数的执⾏上下⽂弹出栈。
- 当分配的调⽤栈空间被占满时，会引发“堆栈溢出”问题。


### 第九章 块级作⽤域：var缺陷以及为什么要引⼊let和const？

`作⽤域（scope）`

作⽤域是指在程序中定义变量的区域，该位置决定了变量的⽣命周期。通俗地理解，作⽤域就是变量与函数
的可访问范围，即作⽤域控制着变量和函数的可⻅性和⽣命周期。

在ES6之前，ES的作⽤域只有两种：全局作⽤域和函数作⽤域。

- 全局作⽤域中的对象在代码中的任何地⽅都能访问，其⽣命周期伴随着⻚⾯的⽣命周期。
- 函数作⽤域就是在函数内部定义的变量或者函数，并且定义的变量或者函数只能在函数内部被访问。函数
执⾏结束之后，函数内部定义的变量会被销毁。


`变量提升所带来的问题`

- 变量容易在不被察觉的情况下被覆盖掉

```js
var myname = "极客时间"
function showName(){
  console.log(myname);
  if(0){
    var myname = "极客邦"
  }
  console.log(myname);
}
showName()
```

- 本应销毁的变量没有被销毁
```js
function foo(){
  for (var i = 0; i < 7; i++) {
  }
  console.log(i);
}
foo()
```

`ES6是如何解决变量提升带来的缺陷`

ES6引⼊了let和const关键字，从⽽使JavaScript也能像其他语⾔⼀样拥有了块级作⽤域。

```js
function letTest() {
  let x = 1;
  if (true) {
    let x = 2; // 不同的变量
    console.log(x); // 2
  }
  console.log(x); // 1
}
```

JavaScript引擎并不会把if块中通过let声明的变量存放到变量环境中，这也就意味着在if块通过let
声明的关键字，并不会提升到全函数可⻅。所以在if块之内打印出来的值是2，跳出语块之后，打印出来的
值就是1了


`JavaScript是如何⽀持块级作⽤域的`

```js
function foo(){
  var a = 1
  let b = 2
  {
    let b = 3
    var c = 4
    let d = 5
    console.log(a)
    console.log(b)
  }
  console.log(b)
  console.log(c)
  console.log(d)
}
foo()
```

- 函数内部通过var声明的变量，在编译阶段全都被存放到变量环境⾥⾯了
- 通过let声明的变量，在编译阶段会被存放到词法环境（Lexical Environment）中。
- 在函数的作⽤域内部，通过let声明的变量并没有被存放到词法环境中。

当进⼊函数的作⽤域块时，作⽤域块中通过let声明的变量，会被存放在词法环境的⼀个
单独的区域中，这个区域中的变量并不影响作⽤域块外⾯的变量，⽐如在作⽤域外⾯声明了变量b，在该作
⽤域块内部也声明了变量b，当执⾏到作⽤域内部时，它们都是独⽴的存在。

在词法环境内部，维护了⼀个⼩型栈结构，栈底是函数最外层的变量，进⼊⼀个作⽤域块后，就会把
该作⽤域块内部的变量压到栈顶；当作⽤域执⾏完成之后，该作⽤域的信息就会从栈顶弹出，这就是词法环
境的结构

### 第十章 作⽤域链和闭包：代码中出现相同的变量，JavaScript引擎是如何选择的？

`作⽤域链`

在每个执⾏上下⽂的变量环境中，都包含了⼀个外部引⽤，⽤来指向外部的执⾏上下⽂，我们把这个外
部引⽤称为outer。

在JavaScript执⾏过程中，其作⽤域链是由词法作⽤域决定的。

`词法作⽤域`

词法作⽤域就是指作⽤域是由代码中函数声明的位置来决定的，所以词法作⽤域是静态的作⽤域，通过它就
能够预测代码在执⾏过程中如何查找标识符。

词法作⽤域是代码阶段就决定好的，和函数是怎么调⽤的没有关系。


`块级作⽤域中的变量查找`

在编写代码的时候，如果你使⽤了⼀个在当前作⽤域中不存在的变量，这时JavaScript引擎就需
要按照作⽤域链在其他作⽤域中查找该变量

```js
function bar() {
  var myName = "极客世界"
  let test1 = 100
  if (1) {
    let myName = "Chrome浏览器"
    console.log(test)
  }
}
function foo() {
  var myName = "极客邦"
  let test = 2
  {
    let test = 3
    bar()
  }
}
var myName = "极客时间"
let myAge = 10
let test = 1
foo()
```

`闭包`

在JavaScript中，根据词法作⽤域的规则，内部函数
总是可以访问其外部函数中声明的变量，当通过调⽤⼀个外部函数返回⼀个内部函数后，即使该外部函数已
经执⾏结束了，但是内部函数引⽤外部函数的变量依然保存在内存中，我们就把这些变量的集合称为闭包。
⽐如外部函数是foo，那么这些变量的集合就称为foo函数的闭包。

```js
function foo() {
  var myName = "极客时间"
  let test1 = 1
  const test2 = 2
  var innerBar = {
    getName:function(){
      console.log(test1)
      return myName
    },
    setName:function(newName){
      myName = newName
    }
  }
}

var bar = foo()
bar.setName("极客邦")
bar.getName()
console.log(bar.getName())
```

>JavaScript引擎会沿着“当前执⾏上下⽂‒>foo函数闭包‒>全局执⾏上下⽂”的顺序来查找myName变量，


`闭包是怎么回收的`

如果引⽤闭包的函数是⼀个全局变量，那么闭包会⼀直存在直到⻚⾯关闭；但如果这个闭包以后不再
使⽤的话，就会造成内存泄漏。

如果引⽤闭包的函数是个局部变量，等函数销毁后，在下次JavaScript引擎执⾏垃圾回收时，判断闭包这块
内容如果已经不再被使⽤了，那么JavaScript引擎的垃圾回收器就会回收这块内存。

所以在使⽤闭包的时候，你要尽量注意⼀个原则：如果该闭包会⼀直使⽤，那么它可以作为全局变量⽽存
在；但如果使⽤频率不⾼，⽽且占⽤内存⼜⽐较⼤的话，那就尽量让它成为⼀个局部变量。


### 第十一章 this：从JavaScript执⾏上下⽂的视⻆讲清楚this

`JavaScript中的this是什么`

this是和执行上下文绑定的

执行上下文分三种：
- 全局执行上下文
- 函数执行上下文
- eval执行上下文
所以对应的this也只有这三种⸺全局执⾏上下⽂中的this、函数中的this和eval中的this。

`全局执⾏上下⽂中的this`

全局执⾏上下⽂中的this是指向window对象的。这也是this和作⽤域链的唯⼀交点，作⽤域链的最底端包含了window对象，全局执⾏上下⽂中的this也是指向window对象。

`函数执⾏上下⽂中的this`

有下⾯三种⽅式来设置函数执⾏上下⽂中的this值:
- 通过函数的call⽅法设置

  ```js
  let bar = {
    myName : "极客邦",
    test1 : 1
  }
  function foo(){
    this.myName = "极客时间"
  }
  foo.call(bar)
  console.log(bar)
  console.log(myName)
  ```

  >实除了call⽅法，还可以使⽤bind和apply⽅法来设置函数执⾏上下⽂中的this

- 通过对象调⽤⽅法设置

  ```js
  var myObj = {
    name : "极客时间",
    showThis: function(){
      console.log(this)
    }
  }
  myObj.showThis()
  ```

  >使⽤对象来调⽤其内部的⼀个⽅法，该⽅法的this是指向对象本⾝的。

  结论：

    1、在全局环境中调⽤⼀个函数，函数内部的this指向的是全局变量window。

    2、通过⼀个对象来调⽤其内部的⼀个⽅法，该⽅法的执⾏上下⽂中的this指向对象本⾝。


- 通过构造函数中设置
  ```js
  function CreateObj(){
  this.name = "极客时间"
  }
  var myObj = new CreateObj()
  ```

### 第十二章 栈空间和堆空间：数据是如何存储的？

`JavaScript是什么类型的语⾔`

在声明变量之前需要先定义变量类型。我们把这种在使⽤之前就需要确认其变量数据类型的称为静态语⾔。相反地，我们把在运⾏过程中需要检查数据类型的语⾔称为动态语⾔


⽀持隐式类型转换的语⾔称为弱类型语⾔，不⽀持隐式类型转换的语⾔称为强类型语⾔

`JavaScript的数据类型`

JavaScript是⼀种弱类型的、动态的语⾔:
- 弱类型，意味着你不需要告诉JavaScript引擎这个或那个变量是什么数据类型，JavaScript引擎在运⾏代
码的时候⾃⼰会计算出来。
- 动态，意味着你可以使⽤同⼀个变量保存不同类型的数据。

JavaScript中的数据类型⼀种有8种，它们分别是：
- Boolean,只有true和false两个值
- Null，只有一个null
- Undefined，一个没有被赋值的变量会有个默认值undefined，变量提升时的默认值也是undefined
- Number，根据ECMAScript标准，Javascript中只有一种数字类型：基于IEEE754标准的双精度64位二进制格式的值，-（263-1）到263-1
- BigInt，Javascript中一个新的数字类型，可以用任意精度表示整数。使用BigInt，即时超出Number的安全整数范围限制，也可以安全地存储和操作。
- String，用于表示文本数据。不同于类C语言，Javascript的字符串是不可更改的。
- Symbol，符号类型是唯一的并且是不可修改的，通常用来作为Object的Key
- Object，在Javascript里，对象可以被看作是一组属性的集合

前⾯的7种数据类型称为原始类型，把最后⼀个对象类型称为引⽤类型，之所以把它们区分为两种不同的类型，是因为它们在内存中存放的位置不⼀样。

`内存空间`

在JavaScript的执⾏过程中， 主要有三种类型内存空间，分别是代码空间、栈空间和堆空间。其中的代码空间主要是存储可执⾏代码的

`栈空间和堆空间`

当执⾏⼀段代码时，需要先编译，并创建执⾏上下⽂，然后再按照顺序执⾏代码。

对象类型是存放在堆空间的，在栈空间中只是保留了对象的引⽤地址，当JavaScript需要访问该数据的时候，是通过栈中的引⽤地址来访问的，相当于多了⼀道转⼿流程。

原始类型的数据值都是直接保存在“栈”中的，引⽤类型的值是存放在“堆”中的。

JavaScript引擎需要⽤栈来维护程序执⾏期间上下⽂的状态，如果栈空间⼤了话，所有的数据都存放在栈空间⾥⾯，那么会影响到上下⽂切换的效率，进⽽⼜影响到整个程序的执⾏效率。

通常情况下，栈空间都不会设置太⼤，主要⽤来存放⼀些原始类型的⼩数据。⽽引⽤类型的数据占⽤的空间都⽐较⼤，所以这⼀类数据会被存放到堆中，堆空间很⼤，能存放很多⼤的数据，不过缺点是分配内存和回收内存都会占⽤⼀定的时间。

在JavaScript中，赋值操作和其他语⾔有很⼤的不同，原始类型的赋值会完整复制变量值，⽽引⽤类型的赋
值是复制引⽤地址。

`再谈闭包`

```js
function foo() {
  var myName = "极客时间"
  let test1 = 1
  const test2 = 2
  var innerBar = {
    setName:function(newName){
      myName = newName
    },
    getName:function(){
      console.log(test1)
      return myName
    }
  }
  return innerBar
}
var bar = foo()
bar.setName("极客邦")
bar.getName()
console.log(bar.getName())
```

- 当JavaScript引擎执⾏到foo函数时，⾸先会编译，并创建⼀个空执⾏上下⽂。
- 在编译过程中，遇到内部函数setName，JavaScript引擎还要对内部函数做⼀次快速的词法扫描，发现
该内部函数引⽤了foo函数中的myName变量，由于是内部函数引⽤了外部函数的变量，所以JavaScript
引擎判断这是⼀个闭包，于是在堆空间创建换⼀个“closure(foo)”的对象（这是⼀个内部对象，
JavaScript是⽆法访问的），⽤来保存myName变量。
- 接着继续扫描到getName⽅法时，发现该函数内部还引⽤变量test1，于是JavaScript引擎⼜将test1添加
到“closure(foo)”对象中。这时候堆中的“closure(foo)”对象中就包含了myName和test1两个变量
了。
- 由于test2并没有被内部函数引⽤，所以test2依然保存在调⽤栈中。

总的来说，产⽣闭包的核⼼有两步：第⼀步是需要预扫描内部函数；第⼆步是把内部函数引⽤的外部变量保
存到堆中。

### 第十三章 栈空间和堆空间：数据是如何存储的？

`不同语⾔的垃圾回收策略`

通常情况下，垃圾数据回收分为⼿动回收和⾃动回收两种策略。

如C/C++就是使⽤⼿动回收策略，何时分配内存、何时销毁内存都是由代码控制的。

另外⼀种使⽤的是⾃动垃圾回收的策略，如JavaScript、Java、Python等语⾔，产⽣的垃圾数据是由垃圾
回收器来释放的，并不需要⼿动通过代码来释放。

`调⽤栈中的数据是如何回收的`

记录当前执⾏状态的指针（称为ESP），指向调用栈中正在执行的函数的执行上下文。当ESP下移到下一个执行上下文，这个下移操作就是销毁当前的执行上下文的过程。

也就是当⼀个函数执⾏结束之后，JavaScript引擎会通过向下移动ESP来销毁该函数保存在栈中的执⾏
上下⽂。

`堆中的数据是如何回收的`

要回收堆中的垃圾数据，就需要⽤到JavaScript中的垃圾回收器了。

`代际假说和分代收集`

代际假说有以下两个特点：
- 第⼀个是⼤部分对象在内存中存在的时间很短，简单来说，就是很多对象⼀经分配内存，很快就变得不可访问；
- 第⼆个是不死的对象，会活得更久。

在V8中会把堆分为新⽣代和⽼⽣代两个区域，新⽣代中存放的是⽣存时间短的对象，⽼⽣代中存放的⽣存时间久的对象。

新⽣区通常只⽀持1〜8M的容量，⽽⽼⽣区⽀持的容量就⼤很多了。对于这两块区域，V8分别使⽤两个不同
的垃圾回收器，以便更⾼效地实施垃圾回收。

- 副垃圾回收器，主要负责新⽣代的垃圾回收。
- 主垃圾回收器，主要负责⽼⽣代的垃圾回收。

`垃圾回收器的⼯作流程`

- 第⼀步是标记空间中活动对象和⾮活动对象。所谓活动对象就是还在使⽤的对象，⾮活动对象就是可以进⾏
垃圾回收的对象。
- 第⼆步是回收⾮活动对象所占据的内存。其实就是在所有的标记完成之后，统⼀清理内存中所有被标记为可
回收的对象。
- 第三步是做内存整理。⼀般来说，频繁回收对象后，内存中就会存在⼤量不连续空间，我们把这些不连续的
内存空间称为内存碎⽚。当内存中出现了⼤量的内存碎⽚之后，如果需要分配较⼤连续内存的时候，就有可
能出现内存不⾜的情况。所以最后⼀步需要整理这些内存碎⽚，但这步其实是可选的，因为有的垃圾回收器
不会产⽣内存碎⽚，⽐如接下来我们要介绍的副垃圾回收器。

`副垃圾回收器`

副垃圾回收器主要负责新⽣区的垃圾回收。⽽通常情况下，⼤多数⼩的对象都会被分配到新⽣区，所以说这
个区域虽然不⼤，但是垃圾回收还是⽐较频繁的。

新⽣代中⽤Scavenge算法来处理。所谓Scavenge算法，是把新⽣代空间对半划分为两个区域，⼀半是对象
区域，⼀半是空闲区域。


`主垃圾回收器`

主垃圾回收器主要负责⽼⽣区中的垃圾回收。除了新⽣区中晋升的对象，⼀些⼤的对象会直接被分配到⽼⽣
区。因此⽼⽣区中的对象有两个特点，⼀个是对象占⽤空间⼤，另⼀个是对象存活时间⻓。

主垃圾回收器是采⽤标记-清除（Mark-Sweep）的算法进⾏垃圾回收的。


### 第十四章 编译器和解释器：V8是如何执⾏⼀段JavaScript代码的？

`编译器和解释器`

之所以存在编译器和解释器，是因为机器不能直接理解我们所写的代码，所以在执⾏程序之前，需要将我们
所写的代码“翻译”成机器能读懂的机器语⾔。

按语⾔的执⾏流程，可以把语⾔划分为编译型语⾔和解释型语⾔:

- 编译型语⾔在程序执⾏之前，需要经过编译器的编译过程，并且编译之后会直接保留机器能读懂的⼆进制⽂
件，这样每次运⾏程序时，都可以直接运⾏该⼆进制⽂件，⽽不需要再次重新编译了。
- 解释型语⾔编写的程序，在每次运⾏时都需要通过解释器对程序进⾏动态解释和执⾏。⽐如Python、
JavaScript等都属于解释型语⾔。

⼆者的执⾏流程，⼤致可阐述为如下：
- 在编译型语⾔的编译过程中，编译器⾸先会依次对源代码进⾏词法分析、语法分析，⽣成抽象语法树
（AST），然后是优化代码，最后再⽣成处理器能够理解的机器码。如果编译成功，将会⽣成⼀个可执⾏
的⽂件。但如果编译过程发⽣了语法或者其他的错误，那么编译器就会抛出异常，最后的⼆进制⽂件也
不会⽣成成功。
- 在解释型语⾔的解释过程中，同样解释器也会对源代码进⾏词法分析、语法分析，并⽣成抽象语法树
（AST），不过它会再基于抽象语法树⽣成字节码，最后再根据字节码来执⾏程序、输出结果。

`V8是如何执⾏⼀段JavaScript代码的`

V8在执⾏过程中既有解释器Ignition，⼜有编译器TurboFan:
- ⽣成抽象语法树（AST）和执⾏上下⽂

  ⾼级语⾔是开发者可以理解的语⾔，但是让编译器或者解释器来理解就⾮常困难了。对于编译器或者解释器来说，它们可以理解的就是AST了。所以⽆论你使⽤的是解释型语⾔还是编译型语⾔，在编译过程中，它们都会⽣成⼀个AST。这和渲染引擎将HTML格式⽂件转换为计算机可以理解的DOM树的情况类似。

  AST是⾮常重要的⼀种数据结构，在很多项⽬中有着⼴泛的应⽤。其中最著名的⼀个项⽬是Babel。

  Babel的⼯作原理就是先将ES6源码转换为AST，然后再将ES6语法的AST转换为ES5语法的AST，最后利⽤ES5的AST⽣成JavaScript源代码。

  除了Babel外，还有ESLint也使⽤AST。ESLint是⼀个⽤来检查JavaScript编写规范的插件，其检测流程也是需要将源码转换为AST，然后再利⽤AST来检查代码规范化的问题。

  ⽣成AST需要经过两个阶段：
  - 第⼀阶段是分词（tokenize），⼜称为词法分析，其作⽤是将⼀⾏⾏的源码拆解成⼀个个token。所
谓token，指的是语法上不可能再分的、最⼩的单个字符或字符串。
  - 第⼆阶段是解析（parse），⼜称为语法分析，其作⽤是将上⼀步⽣成的token数据，根据语法规则转为AST。如果源码符合语法规则，这⼀步就会顺利完成。但如果源码存在语法错误，这⼀步就会终⽌，并抛出⼀个“语法错误”。

- ⽣成字节码

  有了AST和执⾏上下⽂后，那接下来的第⼆步，解释器Ignition就登场了，它会根据AST⽣成字节码，并解释执⾏字节码。

  字节码就是介于AST和机器码之间的⼀种代码。但是与特定类型的机器码⽆关，字节码需要通过解释器将其
转换为机器码后才能执⾏。

  机器码所占⽤的空间远远超过了字节码，所以使⽤字节码可以减少系统的内存使⽤。
- 执⾏代码

  ⽣成字节码之后，接下来就要进⼊执⾏阶段了。

  通常，如果有⼀段第⼀次执⾏的字节码，解释器Ignition会逐条解释执⾏。在执⾏字节码的过程中，如果发
现有热点代码（HotSpot），⽐如⼀段代码被重复执⾏多次，这种就称为热点代码，那么后台的编译器
TurboFan就会把该段热点的字节码编译为⾼效的机器码，然后当再次执⾏这段被优化的代码时，只需要执
⾏编译后的机器码就可以了，这样就⼤⼤提升了代码的执⾏效率。

  V8的解释器和编译器的取名也很有意思。解释器Ignition是点⽕器的意思，编译器TurboFan是涡轮增压的意
思，寓意着代码启动时通过点⽕器慢慢发动，⼀旦启动，涡轮增压介⼊，其执⾏效率随着执⾏时间越来越⾼
效率，因为热点代码都被编译器TurboFan转换了机器码，直接执⾏机器码就省去了字节码“翻译”为机器
码的过程。

  其实字节码配合解释器和编译器是最近⼀段时间很⽕的技术，⽐如Java和Python的虚拟机也都是基于这种
技术实现的，我们把这种技术称为即时编译（JIT）。具体到V8，就是指解释器Ignition在解释执⾏字节码
的同时，收集代码信息，当它发现某⼀部分代码变热了之后，TurboFan编译器便闪亮登场，把热点的字节
码转换为机器码，并把转换后的机器码保存起来，以备下次使⽤。

`JavaScript的性能优化`

对于优化JavaScript执⾏效率，你应该将优化的中⼼聚焦在单次脚本的执⾏时间和脚本的⽹络下载上，主要关注以下
三点内容：
- 提升单次脚本的执⾏速度，避免JavaScript的⻓任务霸占主线程，这样可以使得⻚⾯快速响应交互；
- 避免⼤的内联脚本，因为在解析HTML的过程中，解析和编译也会占⽤主线程；
- 减少JavaScript⽂件的容量，因为更⼩的⽂件会提升下载速度，并且占⽤更低的内存。

### 第十五章 消息队列和事件循环：⻚⾯是怎么“活”起来的？

`使⽤单线程处理安排好的任务`

```C++
void MainThread(){
  int num1 = 1+2; //任务1
  int num2 = 20/5; //任务2
  int num3 = 7*8; //任务3
  print("最终计算的值为:%d,%d,%d",num,num2,num3)； //任务4
}
```
在上⾯的执⾏代码中，我们把所有任务代码按照顺序写进主线程⾥，等线程执⾏时，这些任务会按照顺序在
线程中依次被执⾏；等所有任务执⾏完成之后，线程会⾃动退出。

`在线程运⾏过程中处理新任务`

要想在线程运⾏过程中，能接收并执⾏新的任务，就需要采⽤事件循环机制


```C++
//GetInput
//等待⽤⼾从键盘输⼊⼀个数字，并返回该输⼊的数字
int GetInput(){
  int input_number = 0;
  cout<<"请输⼊⼀个数:";
  cin>>input_number;
  return input_number;
}
//主线程(Main Thread)
void MainThread(){
  for(;;){
    int first_num = GetInput()；
    int second_num = GetInput()；
    result_num = first_num + second_num;
    print("最终计算的值为:%d",result_num)；
  }
}
```

相较于第⼀版的线程，这⼀版的线程做了两点改进。

- 第⼀点引⼊了循环机制，具体实现⽅式是在线程语句最后添加了⼀个for循环语句，线程会⼀直循环执
⾏。
- 第⼆点是引⼊了事件，可以在线程运⾏过程中，等待⽤⼾输⼊的数字，等待过程中线程处于暂停状态，⼀
旦接收到⽤⼾输⼊的信息，那么线程会被激活，然后执⾏相加运算，最后输出结果。

`处理其他线程发送过来的任务`

渲染主线程会频繁接收到来⾃于IO线程的⼀些任务，接收到这些任务之后，渲染进程就需
要着⼿处理，⽐如接收到资源加载完成的消息后，渲染进程就要着⼿进⾏DOM解析了；接收到⿏标点击的
消息后，渲染主线程就要开始执⾏相应的JavaScript脚本来处理该点击事件。

消息队列是⼀种数据结构，可以存放要执⾏的任务。它符合队列“先进先出”的特点，也
就是说要添加任务的话，添加到队列的尾部；要取出任务的话，从队列头部去取。

- 添加⼀个消息队列；
- IO线程中产⽣的新任务添加进消息队列尾部；
- 渲染主线程会循环地从消息队列头部中读取任务，执⾏任务。

由于是多个线程操作同⼀个消息队列，所以在添加任务和取出任务时还会加上⼀个同步锁

`处理其他进程发送过来的任务`

渲染进程专⻔有⼀个IO线程⽤来接收其他进程传进来的消息，接收到消息之后，会将这些消息组装成任务发送给渲染主线程，后续的步骤就和前⾯讲解的“处理其他线程发送的任务”⼀样了

`消息队列中的任务类型`

如输⼊事件（⿏标滚动、点击、移动）、微任务、⽂件读写、WebSocket、JavaScript定时器等等。

除此之外，消息队列中还包含了很多与⻚⾯相关的事件，如JavaScript执⾏、解析DOM、样式计算、布局计
算、CSS动画等。

以上这些事件都是在主线程中执⾏的，所以在编写Web应⽤时，你还需要衡量这些事件所占⽤的时⻓，并想
办法解决单个任务占⽤主线程过久的问题。

`如何安全退出`

Chrome是这样解决的，确定要退出当前⻚⾯时，⻚⾯主线程会设置⼀个退出标志的变量，在每次执⾏完⼀个任务时，判断是否有设置退出标志。

如果设置了，那么就直接中断当前的所有任务，退出线程，

`⻚⾯使⽤单线程的缺点`

- 第⼀个问题是如何处理⾼优先级的任务。

  消息队列中的任务称为宏任务，每个宏任务中都包含了⼀个微任务队列，在执⾏宏任务的过程
  中，如果DOM有变化，那么就会将该变化添加到微任务列表中，这样就不会影响到宏任务的继续执⾏，因
  此也就解决了执⾏效率的问题。

  等宏任务中的主要功能都直接完成之后，这时候，渲染引擎并不着急去执⾏下⼀个宏任务，⽽是执⾏当前宏
  任务中的微任务，因为DOM变化的事件都保存在这些微任务队列中，这样也就解决了实时性问题。

- 第⼆个是如何解决单个任务执⾏时⻓过久的问题。

  所有的任务都是在单线程中执⾏的，所以每次只能执⾏⼀个任务，⽽其他任务就都处于等待状态。如果
其中⼀个任务执⾏时间过久，那么下⼀个任务就要等待很⻓时间。

  如果在执⾏动画过程中，其中有个JavaScript任务因执⾏时间过久，占⽤了动画单帧的
时间，这样会给⽤⼾制造了卡顿的感觉，这当然是极不好的⽤⼾体验。针对这种情况，JavaScript可以通过
回调功能来规避这种问题，也就是让要执⾏的JavaScript任务滞后执⾏。

### 第十六章 WebAPI：setTimeout是如何实现的？

浏览器⻚⾯是由消息队列和事件循环系统来驱动的。

setTimeout就是⼀个定时器，⽤来指定某个函数在多少毫秒之后执⾏。它会返回⼀个整数，表⽰定时器的编号，同时你还可以通过该编号来取消这个定时器

`浏览器怎么实现setTimeout`

通过定时器设置回调函数有点特别，它们需要在指定的时间间隔内被调⽤，但消息队列中的任务是按照顺序执⾏的，所以为了保证回调函数能在指定时间内执⾏，你不能将定时器的回调函数直接添加到消息队列中。

在Chrome中除了正常使⽤的消息队列之外，还有另外⼀个消息队列，这个队列中维护了需要延迟执⾏的任
务列表，包括了定时器和Chromium内部⼀些需要延迟执⾏的任务。所以当通过JavaScript创建⼀个定时器
时，渲染进程会将该定时器的回调任务添加到**延迟队列**中。
- 当通过JavaScript调⽤setTimeout设置回调函数的时候，渲染进程将会创建⼀个回调任务，包含了回调函
数showName、当前发起时间、延迟执⾏时间
- 创建好回调任务之后，再将该任务添加到延迟执⾏队列中

处理完消息队列中的⼀个任务之后，就开始执⾏ProcessDelayTask函数。ProcessDelayTask函数会根据发起时间和延迟时间计算出到期的任务，然后依次执⾏这些到期的任务。等到期的任务执⾏完成之后，再继续下⼀个循环过程

`使⽤setTimeout的⼀些注意事项`

- 如果当前任务执⾏时间过久，会延迟到期定时器任务的执⾏
- 如果setTimeout存在嵌套调⽤，那么系统会设置最短时间间隔为4毫秒
- 未激活的⻚⾯，setTimeout执⾏最⼩间隔是1000毫秒
- 延时执⾏时间有最⼤值，setTimeout设置的延迟值⼤于 2147483647毫秒（⼤约24.8天）时就会溢出，这导致定时器会被⽴即执⾏
- 使⽤setTimeout设置的回调函数中的this不符合直觉
  setTimeout推迟执⾏的回调函数是某个对象的⽅法，那么该⽅法中的this关键字将指向全局环境

### 第十七章 WebAPI：XMLHttpRequest是怎么实现的？

`回调函数 VS 系统调⽤栈`

将⼀个函数作为参数传递给另外⼀个函数，那作为参数的这个函数就是回调函数

```js
let callback = function(){
  console.log('i am do homework')
}
function doWork(cb) {
  console.log('start do work')
  cb()
  console.log('end do work')
}
doWork(callback)
```

回调函数callback是在主函数doWork返回之前执⾏的，我们把这个回调过程称为同步回调。

```js
let callback = function(){
  console.log('i am do homework')
}
function doWork(cb) {
  console.log('start do work')
  setTimeout(cb,1000)
  console.log('end do work')
}
doWork(callback)
```

使⽤了setTimeout函数让callback在doWork函数执⾏结束后，⼜延时了1秒再执⾏，这次callback并没有在主函数doWork内部被调⽤，我们把这种回调函数在主函数外部执⾏的过程称为异步回调。

消息队列和主线程循环机制保证了⻚⾯有条不紊地运⾏。

当循环系统在执⾏⼀个任务的时候，都要为这个任务维护⼀个系统调⽤栈

整个Parse HTML是⼀个完整的任务，在执⾏过程中的脚本解析、样式表解析都是该任务的⼦过程，其下拉的⻓条就是执⾏过程中调⽤栈的信息。

每个任务在执⾏过程中都有⾃⼰的调⽤栈，那么同步回调就是在当前主函数的上下⽂中执⾏回调函数

异步回调是指回调函数在主函数之外执⾏，⼀般有两种⽅式：

- 第⼀种是把异步函数做成⼀个任务，添加到信息队列尾部；
- 第⼆种是把异步函数添加到微任务队列中，这样就可以在当前任务的末尾处执⾏微任务了。

`XMLHttpRequest运作机制`

渲染进程会将请求发送给⽹络进程，然后⽹络进程负责资源的下载，等⽹络进程接收到数据之后，就会
利⽤IPC来通知渲染进程；渲染进程接收到消息之后，会将xhr的回调函数封装成任务并添加到消息队列中，
等主线程循环系统执⾏到该任务的时候，就会根据相关的状态来调⽤对应的回调函数

`XMLHttpRequest使⽤过程中的“坑”`

- 跨域问题
- HTTPS混合内容的问题

  HTTPS混合内容是HTTPS⻚⾯中包含了不符合HTTPS安全要求的内容，⽐如包含了HTTP资源，通过HTTP加载的图像、视频、样式表、脚本等，都属于混合内容。

### 第十八章 宏任务和微任务：不是所有任务都是⼀个待遇

`宏任务`

⻚⾯中的⼤部分任务都是在主线程上执⾏的，这些任务包括了：

- 渲染事件（如解析DOM、计算布局、绘制）；
- ⽤⼾交互事件（如⿏标点击、滚动⻚⾯、放⼤缩⼩等）；
- JavaScript脚本执⾏事件；
- ⽹络请求完成、⽂件读写完成事件。

渲染进程内部会维护多个消息队列，⽐如延迟执⾏队列和普通的消息队列。然后主线程采⽤⼀个for循环，不断地从这些任务队列中取出任务并执⾏任务。我们把这些消息队列中的任务称为宏任务。

宏任务的时间粒度⽐较⼤，执⾏的时间间隔是不能精确控制的，对⼀些⾼实时性的需求就不太符合
了，⽐如后⾯要介绍的监听DOM变化的需求。

`微任务`

第⼀种是把异步回调函数封装成⼀个宏任务，添加到消息队列尾部，当循环系统执⾏到该任务的时候执⾏回
调函数。这种⽐较好理解，我们前⾯介绍的setTimeout和XMLHttpRequest的回调函数都是通过这种⽅式来
实现的。

第⼆种⽅式的执⾏时机是在主函数执⾏结束之后、当前宏任务结束之前执⾏回调函数，这通常都是以微任务
形式体现的。

微任务就是⼀个需要异步执⾏的函数，执⾏时机是在主函数执⾏结束之后、当前宏任务结束之前。