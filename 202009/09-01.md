## 2020-09-01

## 前端基础体系

### 确定知识体系

高效学习三部曲：找准知识体系、刻意训练、及时反馈

#### 从哪些方面梳理知识体系

- W3C 标准
- ECMA 262 标准
- 开发环境
- 运行环境

#### 基础知识体系

- JS 基础语法
- JS-WEB-API
- 开发环境
- 运行环境

### 2.变量类型和计算

#### 2.1.值类型和引用类型

变量是存储在在栈内存当中的，值类型的值也存储在栈内存中，而引用类型的栈内存存储的是堆内存的地址，引用类型的值实际存储在堆内存中。

- 常见值类型

```js
let a; // undefined
const n = 123;
const s = "123";
const b = true;
const s = Symbol("s");
```

- 常见引用类型

```js
const obj = { age: 20 }
const arr = [1, 2, 3]
const n = null // null是特殊的引用类型，指针指向的是一个空地址
function fn() {...} // 函数也是特殊的引用类型，但不存储实际数据，所以没有“拷贝，复制函数”这一说法
```

#### 2.2.typeof 运算符和深拷贝

typeof 运算符作用：(typeof 可以判断哪些类型)

- 能识别所有的值类型
- 识别函数
- 识别是否是引用类型（但不能细分）

```js
// 所有值类型
let a                     typeof a // undefined
const s = '123'           typeof s // string
const n = 123             typeof n // number
const b = true            typeof b // boolean
const s = Symbol('s')     typeof s // symbol


// 能判断函数
typeof console.log    // function
typeof function() {}  // function

// 能识别引用类型
typeof null     // object
typeof [1, 2]   // object
typeof { a: 1, b:2 } // object
```

深拷贝

```js
function deepClone(obj) {
  if (typeof obj !== "object" || obj == null) {
    // obj 是null, 或者不是对象和数组，直接返回
    return obj;
  }

  let result;
  // 区分数组还是json
  if (obj instanceof Array) {
    result = [];
  } else {
    result = {};
  }

  for (let key in obj) {
    // 防止遍历原型链上的属性
    if (obj.hasOwnProperty(key)) {
      result[key] = deepClone(obj[k]);
    }
  }
  return result;
}
```

#### 2.3.变量计算

类型转换：

- 字符串拼接
  ```js
  const a = 100 + 10; // 110
  const b = 100 + "10"; // 10010
  const c = true + "10"; // true10
  ```
- ==运算符（系统会尝试进行类型转换使得比较的两个值是否相等）
  ```js
  100 == "100"; // true
  0 == ""; // true
  0 == false; // true
  false == ""; // true
  null == undefined; // true
  // 何时使用 === 何时使用==
  // 除 == null之外，其它都一律用 ===，
  const obj = { age: 20 };
  if (obj.age == null) {
  }
  // 相当于
  // if (obj.age === null || obj.age === undefined)
  ```
- if 语句和逻辑运算

  1. truly 变量： !!a === true 的变量
  2. falsely 变量： !!b === false 的变量

  ```js
  // 以下都是falsely变量，其它一律都是truly变量
  !!0 === false;
  !!NaN === false;
  !!"" === false;
  !!null = false;
  !!undefined = false;
  !!false === false;
  ```

  ```js
  console.log(10 && 0); // 0
  console.log("" && "abc"); // 'abc'
  console.log(!window.abc); // true
  ```

### 3.原型和原型链

相关题目：

- 如何准确判断一个变量是不是数组
- 手写一个简易 jQuery，考虑插件和扩展性
- class 本质，怎么理解

知识点：

- class 和继承
- 类型判断 instanceof
- 原型和原型链

#### 3.1.class 和继承

class

- constructor
- 属性和方法

继承

- extends
- super
- 扩张或重写方法

```js
class Person {
  constructor(name) {
    this.name = name;
  }
  eat() {
    console.log(`${this.name} eat something`);
  }
}

class Student extends Person {
  constructor(name, number) {
    super(name);
    this.number = number;
  }
  sayHi() {
    console.log(`my name is ${this.name}, my number is ${this.number}`);
  }
}

const xialuo = new Student("夏洛", "001");
xialuo.eat();
xialuo.sayHi();
```

#### 3.2.原型

类型判断 instanceof

```js
xialuo instanceof Student // true
xialuo instanceof Person // true
xialuo instanceof Object // true

[] instanceof Array // true
[] instanceof Object // true
{} instanceof Object // true
```

原型

```js
// class实际是函数，可见的语法糖
typeof Person; // 'function'
typeof Student; // 'function'

// 隐式原型和显示原型
console.log(xialuo.__proto__);
console.log(Student.prototype);
console.log(xialuo.__proto__ === Student.prototype);
```

`class的本质答案`

原型关系:

- 每个 class 都有显示原型 prototype
- 每个实例对象都有隐式原型**proto**
- 实例的**proto**指向对应 class 的 prototype

基于原型的执行规则：

- 先从自身的属性和方法寻找
- 如果自身没有再从**proto**寻找

总结：

- class 是 ES6 的语法规范，由 ECMA 委员会发布
- ECMA 只规定语法规则，即我们代码的书写规范，不规定如何实现
- 以上实现方式都是 V8 引擎实现的，也是主流

手写简易 jQuery

```js
class jQuery {
  constructor(selector) {
    const result = document.querySelectorAll(selector);
    const length = result.length;
    for (let i = 0; i < length; i++) {
      this[i] = result[i];
    }
    this.length = length;
    this.selector = selector;
  }
  get(index) {
    return this[index];
  }
  each(fn) {
    for (let i = 0; i < this.length; i++) {
      const elem = this[i];
      fn(elem);
    }
  }
  on(type, fn) {
    return this.each((fn) => {
      elem.addEventListener(type, fn, false);
    });
  }
}

// 插件
jQuery.prototype.dialog = function (info) {
  alert(info);
};
```

### 4.作用域和闭包

#### 4.1 作用域和自由变量

题目：

- this 的不同应用场景，如何取值？
- 手写 bind 函数
- 实际开发中闭包的应用场景，举例说明

作用域：可以表示一个变量的合法使用范围。

- 全局作用域
- 函数作用域
- 块级作用域（es6 新增）

自由变量：

- 一个变量在当前作用域没有定义，但被使用了
- 向上级作用域，一层一层依次寻找，直到找到为止
- 如果到全局作用域都没有找到，就会报 xx is not defined

闭包：

- 作用域应用的特殊情况，有两种表现：
- 函数作用参数被传递
- 函数作为返回值被返回

闭包的作用域是定义的时候确定的，不是执行的时候确定的

即自由变量的查找，是在函数定义的地方，向上级作用域查找，不是在执行的地方向上查找

```js
// 函数作为返回值
function create() {
  const a = 100;
  return function () {
    console.log(a);
  };
}
const a = 200;
const fn = create();
fn();
// 100
```

```js
// 函数作为参数被传递
function print(fn) {
  let a = 200;
  fn();
}

let a = 100;
function fn() {
  console.log(a);
}
print(fn);
// 100
```

this 的使用场景：

- 作为普通函数
- 使用 call apply bind
- 作为对象方法被调用
- 在 class 方法中调用
- 箭头函数，setTimeout 中使用箭头函数，永远指向上级作用

this 取什么值不是函数定义的时候决定的，还是看 this 调用时执行的上下文环境决定的

```js
function fn1() {
  console.log(this)
}

fn1() // window

fn1.call({x: 100}) // {x: 100}

const fn2 = fn1.bind({x: 100})
fn2() // { x: 100 }


const zhangsan = {
  name: '张三',
  sayHi: function() {
    // this指向当前对象
    console.log(this)
  }，
  wait: function(){
    setTimeout(function(){
      // this === window
      console.log(this)
    })
  },
  wait2: function() {
    setTimeout(() => {
      // this指向当前对象
      console.log(this)
    })
  }
}
```

手写 bind 函数

```js
Function.prototype.bind = function () {
  // 将参数拆解为数组
  const args = Array.prototype.slice.call(arguments);

  // 获取第一项
  const t = args.shift();

  // fn1.bind(...) 中的fn1，就像对象实例调用，this指向当前实例
  const self = this;

  // 返回函数
  return function () {
    return self.apply(t, args);
  };
};
```

手写 call 函数

```js
Function.prototype.es3Call = function (context) {
  var content = context || window;
  content.fn = this;
  var args = [];
  // arguments是类数组对象，遍历之前需要保存长度，过滤出第一个传参
  for (var i = 1, len = arguments.length; i < len; i++) {
    // 避免object之类传入
    args.push("arguments[" + i + "]");
  }
  var result = eval("content.fn(" + args + ")");
  delete content.fn;
  return result;
};
```

```js
// apply同理，代码相同
Function.prototype.myCall = function(thisArg, ...args) {
  // 声明一个独有的Symbol属性, 防止fn覆盖已有属性
  const fn = Symbol('fn')
  // 若没有传入this, 默认绑定window对象
  thisArg = thisArg || window
  // this指向调用call的对象,即我们要改变this指向的函数
  thisArg[fn] = this
  // 执行当前函数
  const result = thisArg[fn](...args)
  // 删除我们声明的fn属性
  delete thisArg[fn]
  // 返回函数执行结果
  return result
}
```

手写 apply 函数

```js
Function.prototype.apply = function (context, arr) {
  var context = Object(context) || window;
  context.fn = this;

  var result;
  if (!arr) {
    result = context.fn();
  } else {
    var args = [];
    for (var i = 0, len = arr.length; i < len; i++) {
      args.push("arr[" + i + "]");
    }
    result = eval("context.fn(" + args + ")");
  }

  delete context.fn;
  return result;
};
```

闭包的应用场景：

- 隐藏数据
- 编写一个简易 cache 工具

```js
function createCache() {
  const data = {};
  return {
    set: function (key, value) {
      data[key] = value;
    },
    get: function (key) {
      return data[key];
    },
  };
}

const c = createCache();
c.set("a", 100);
c.get("a");
```

### 5.异步

题目:

- 同步和异步的区别
- 手写 Promise 加载一张图片
- 前端使用异步的场景有哪些

单线程和异步

- JS 是单线程语言，某一个时刻进程只能处理一件事情
- 浏览器和 nodejs 已经 js 启动进程，如 web worker
- JS 和 DOM 渲染共用一个线程，因为 JS 可以修改 DOM 结构
- 遇到等待（网络请求，延迟任务），不能卡住， 需要异步

异步和同步

- 基于 JS 是单线程语言
- 异步不会阻塞代码执行
- 同步会阻塞代码执行

应用场景：

- 网络请求，如 ajax、图片加载
- 定时任务，如 setTimeout

### 异步

题目：

- 请描述 event-loop(事件循环/事件轮询)的机制，可画图
- 什么是宏任务和微任务，两者有什么区别
- Promise 有哪三种状态？如何变化？

#### Event Loop

- JS 是单线程运行的
- 异步要基于回调来实现
- Event Loop 就是异步回调的实现原理
- 异步（定时、网络请求）使用回调，基于 Event Loop
- Dom 事件也是用回调，基于 Event Loop

JS 是如何执行的？

- 程序会按顺序，一行一行的执行
- 如果遇到某一行程序执行出错，则会停止后面的程序执行
- 先执行完同步的代码，再执行异步的代码

Event Loop 过程

- 同步代码，一行一行放在 call stack 执行
- 遇到异步，会先记录下，等待时机（定时、网络请求）
- 时机到了，就移动到 callback queue
- 如果 call stack 为空（即同步代码执行完），Event Loop 就开始工作
- 轮询查找 Callback Queue，如有则移动到 Call stack 执行
- 然后继续轮询查找

#### Promise

Promise 三种状态：

- pending resolved rejected
- pending -> resolved 或 pending -> rejected
- 状态不可逆

状态表现：

- pending 状态，不会触发 then 和 catch
- resolved 状态，会触发后续 then 回调函数
- rejected 状态，会触发后续 catch 回调函数

then 和 catch 改变状态

- then 正常返回 resolved，里面有报错则返回 rejected
- catch 正常返回 resolved，里面有报错则返回 rejected

```js
// 第一题
Promise.resolve()
  .then(() => {
    console.log(1);
  })
  .catch(() => {
    console.log(2);
  })
  .then(() => {
    console.log(3);
  }); // 1 3

// 第二题
Promise.resolve()
  .then(() => {
    console.log(1);
    throw new Error("error1");
  })
  .catch(() => {
    console.log(2);
  })
  .then(() => {
    console.log(3);
  }); // 1 2 3

// 第三题
Promise.resolve()
  .then(() => {
    console.log(1);
    throw new Error("error1");
  })
  .catch(() => {
    console.log(2);
  })
  .catch(() => {
    console.log(3);
  }); // 1 2
```
`手写promise`

```js
function MiniPromise(excute) {
  this.value = ''
  this.reason = ''
  this.status = 'pending'
  
  this.onResolvedQueue = []
  this.onRejectedQueue = []
  
  var self = this
  function resolve(value) {
    if (self.status !== 'pending') {
      return;
    }
    self.value = value
    self.status = 'resolved'
    setTimeout(function() {
      self.onResolvedQueue.forEach(resolved => resolved(self.value))
    })
  }
  
  function reject(value) {
    if (self.status !== 'pending') {
      return;
    }
    self.reason = value
    self.status = 'rejected'
    setTimeout(function() {
      self.onRejectedQueue.forEach(rejected => rejected(self.reason))
    })
  }
  
  excute(resolve, reject)
}

MiniPromise.prototype.then = function(onResolved, onRejected) {
  if (typeof onResolved !== 'function') {
    onResolved = function(x) { return x; }
  }
  
  if (typeof onRejected !== 'function') {
    onRejected = function(e) { return e; }
  }
  
  var self = this
  if (self.status === 'resolved') {
    onResolved(self.value)
  } else if (self.status === 'rejected') {
    onRejected(self.reason)
  } else if (self.status === 'pending') {
    self.onResolvedQueue.push(onResolved)
    self.onRejectedQueue.push(onRejected)
  }
  return this
}

const minP = new MiniPromise(function(resolve, reject) {
  resolve('初始化')
})
minP.then(function(value) {
  console.log(value)
  console.log('then')
}).then(function(value) {
  console.log(value)
})
```
#### async/await

- Promise then catch 链式调用，同样也是基于回调函数
- async/await 是同步语法，可以彻底消灭回调函数

async/await 和 Promise 的关系

- 执行 async 函数，返回的是 Promise 对象
- await 相当于 Promise 的 then
- try...catch 可捕获异常，代替了 Promise 的 catch

```js
async function async1() {
  console.log("async1 start");
  await async2();
  console.log("async1 end");
  await async3();
  console.log("async1 end 2");
}

async function async2() {
  console.log("async2");
}

async function async3() {
  console.log("async3");
}

console.log("script start");
async1();
console.log("script end");
// script start
// async1 start
// async2
// script end
// async1 end
// async3
// async1 end 2
```

#### for...of

- for...in(以及 forEach for)是常规的同步遍历
- for...of 常用于异步的遍历

常用异步遍历，for...of 不同于 forEach 同步遍历出结果，for...of 会等到上一次结果出来之后再往下执行

```js
function multi(num) {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve(num * num);
    }, 1000);
  });
}

const nums = [1, 2, 3];

// 等一秒之后，会一次输出1 4 9
nums.forEach(async (i) => {
  const res = await multi(i);
  console.log(res);
});

// 会分别等待上一次输出1 ， 4 ， 9
!(async function () {
  for (let i of nums) {
    const res = await multi(i);
    console.log(res);
  }
})();
```

#### 宏任务 marcoTask 和微任务 mircoTask

宏任务和微任务都是基于异步回调的

- 宏任务：setTimeout、setInterval、Ajax、DOM 事件
- 微任务：Promise、async/await
- 微任务执行时机比宏任务要早

```js
console.log(100);
// marcoTask
setTimeout(() => {
  console.log(200);
});

// mircoTask
Promise.resolve().then(() => {
  console.log(300);
});

console.log(400);
// 100
// 400
// 300
// 200
```

#### event loop 和 DOM 渲染

- JS 是单线程的，而且和 DOM 渲染共用一个线程
- JS 执行的时候，得留一些时机供 DOM 渲染

  1.call stack 空闲 2.尝试 DOM 渲染 3.触发 EvenLoop

- 每次 call stack 清空（即每次轮询结束），即同步任务执行完
- 都是 DOM 重新渲染的机会，DOM 结果如有改变则重新渲染
- 然后再去触发下一次 Event Loop，以此循环

`微任务和宏任务的区别`

- 宏任务：是在 DOM 渲染后触发，如 setTimeout
- 微任务：是在 DOM 渲染前触发，如 Promise

```js
// 修改 DOM
const $p1 = $("<p>一段文字</p>");
const $p2 = $("<p>一段文字</p>");
const $p3 = $("<p>一段文字</p>");
$("#container").append($p1).append($p2).append($p3);

// // 微任务：渲染之前执行（DOM 结构已更新）
Promise.resolve().then(() => {
  const length = $("#container").children().length;
  alert(`micro task ${length}`);
});

// 宏任务：渲染之后执行（DOM 结构已更新）
setTimeout(() => {
  const length = $("#container").children().length;
  alert(`macro task ${length}`);
});
```

再深入思考一下：为何两者会有以上区别，一个在渲染前，一个在渲染后？

- 微任务：ES 语法标准之内，JS 引擎来统一处理。即，不用浏览器有任何干预，即可一次性处理完，更快更及时。
- 宏任务：ES 语法没有，JS 引擎不处理，浏览器（或 nodejs）干预处理。

  1.call stack 空闲 2.执行当前的微任务 3.尝试 DOM 渲染 4.触发 EvenLoop

### 6.JS-WEB-API

从 JS 基础知识到 JS WEB API

- JS 基础知识，规定语法（ECMA 263 标准）
- JS WEB API，网页操作的 api（W3C 标准）
- 前者是后者的基础，两者相结合才能在实际中应用

- DOM
- BOM
- 事件绑定
- ajax
- 存储

#### DOM 的本质 Document Object Model

题目：

- DOM 是哪种数据结构
- DOM 操作的常用 API
- attr 和 property 的区别
- 一次性插入多个 DOM 节点，考虑性能

xml 是一种可扩展的标记性语言，标签可以自定义，可以描述任何结构的数据

html 可以说一种特殊 xml 语言，因为 html 的标签是定义好的

DOM 的本质就是一棵树，可以理解为 html 编译成的一个树

#### DOM 节点操作

- 获取 DOM 节点
- attribute
- property

DOM 操作的 property：property 是一种 DOM 属性操作的一种形式

property 和 attribute

- property：以对象修改属性值的方式，修改后不会体现到 html 结构中
- attribute：修改 html 标签属性，会体现到 html 结构
- 两者都有可能引起 DOM 结构渲染，但是 property 可以避免一些 DOM 结构重排，attribute 修改了标签结构一定会引起 DOM 结果的重新渲染

```js
// property
const oDiv = document.getElementById("div");
oDiv.style.width = "100px";
oDiv.className = "red";

// attribute
oDiv.setAttribute("data-name", "div");
oDiv.getAttribute("data-name");
oDiv.setAttribute("style", "font-size: 30px");
```

#### DOM 结构操作

- 新增/插入节点（innerHTML, appendChild）
- 获取子元素列表，获取父元素列表
- 删除子元素(removeChild)

```js
// 获取子元素和父元素
const div1 = document.getElementById("div1");
const div2 = document.getElementById("div2");

// 新建节点
const newP = document.createElement("p");
newP.innerHTML = "this is a p";
// 插入节点
div1.appendChild(newP);

// 移动节点
// 针对现有节点操作
const p1 = document.getElementById("p1");
div2.appendChild(p1);
//
const child = div1.childNodes;
// 过滤文本节点，只输出标签节点
const tagChilds = Array.prototype.slice.call(child).filter((node) => {
  // 说明是标签节点
  if (node.nodeType === 1) {
    return true;
  }
  return false;
});
const parent = div1.parentNode;
// 删除节点
div1.removeChild(tagChild[0]);
```

#### DOM 性能

- DOM 操作非常“昂贵”，避免频繁操作 DOM 结构
- 对 DOM 查询做缓存
- 将频繁操作改为一次性操作

```js
// 缓存，避免频繁查询
const list = document.getElementById("list");

// 创建文档片段，文档片段此时并未插入到DOM结构中，还保存在内存中
const frag = document.createDocumentFragment();

for (let i = 0; i < 20; i++) {
  const li = document.createElement("li");
  li.innerHTML = "LIST" + i;
  frag.appendChild(li);
}

// 一次性插入到DOM结构
list.appendChild(frag);
```

### 7.BOM(Browser Object Model)

題目：

- 如何识别浏览器类型
- 分析插接 url 各个部分

```js
// navigator
const ua = navigator.userAgent;
const isChrome = ua.indexOf("chrome");

// screen
console.log(screen.width);
console.log(screen.height);

// location
location.href;
location.protocol;
location.pathname;
location.search;
location.hash;

// history
history.back();
history.forward();
```

### 8.事件

题目：

- 编写一个通用的事件绑定监听函数
- 描述事件冒泡的过程

  - 基于 DOM 树形结构
  - 事件会顺着触发元素往上冒泡
  - 应用场景：代理

- 无限下拉的图片列表，如何监听每个图片的点击
  - 事件代理
  - 用 e.target 获取触发元素
  - 用 matches 来判断是否是触发元素

IE 事件流被称为事件冒泡，这是因为事件被定义为从最具体的元素（文档树中最深的节点）开始触
发，然后向上传播至没有那么具体的元素（文档）

DOM 事件模型分为捕获和冒泡。一个事件发生后，会在子元素和父元素之间传播（propagation）。这种传播分成三个阶段。
（1）捕获阶段：事件从 window 对象自上而下向目标节点传播的阶段；
（2）目标阶段：真正的目标节点正在处理事件的阶段；
（3）冒泡阶段：事件从目标节点自下而上向 window 对象传播的阶段。

捕获是从上到下，事件先从 window 对象，然后再到 document（对象），然后是 html 标签（通过 document.documentElement 获取 html 标签），然后是 body 标签（通过 document.body 获取 body 标签），然后按照普通的 html 结构一层一层往下传，最后到达目标元素。
而事件冒泡的流程刚好是事件捕获的逆过程。

```js
function bindEvent(obj, ev, fn) {
  if (obj.attachEvent) {
    obj.attachEvent("on" + ev, fn);
  } else {
    obj.addEventListener(ev, fn, false);
  }
}

function bindEvent(elem, type, selector, fn) {
  if (fn == null) {
    fn = selector;
    selector = null;
  }

  elem.addEventListener(type, (event) => {
    const target = event.target;
    if (selector) {
      // 代理绑定
      if (target.mateches(selector)) {
        fn.call(target, event);
      }
    } else {
      // 普通绑定
      fn.call(target, event);
    }
  });
}

// 普通绑定
const btn1 = document.getElementById("btn1");
bindEvent(btn1, "click", function (event) {
  event.preventDefault();
  alert(this.innerHTML);
});

// 代理绑定
const div1 = document.getElementById("div1");
bindEvent("div1", "click", "a", function (event) {
  event.preventDefalt();
  alert(this.innerHTML);
});
```

由于事件会在冒泡阶段向上传播到父节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件。这种方法叫做事件的代理（delegation）。

优点：

- 减少内存消耗，提高性能
- 简洁

### 9.ajax

#### 9.1XMLHttpRequest

题目：

- 编写一个简易的 ajax
- 跨域的常见实现方式

```js
const xhr = new XMLHttpRequest();
xhr.send("GET", "/data/test.json", true); //  第三个参数表示请求是同步还是异步 true异步
// 回调
xhr.onreadystatechange = function () {
  if (xhr.readyState === 4) {
    // 服务器返回状态
    if (xhr.status === 200) {
      // 服务器返回信息
      console.log(xhr.responseText);
    } else {
      console.log("其它情况");
    }
  }
};
// 不需要发送参数
xhr.send(null);
```

xhr.readyState

- 0-(未初始化)还没有调用 send()方法
- 1-(载入)已调用 send()方法，正在发送请求
- 2-(载入完成)已执行完 send()方法，已接收全部响应内容
- 3-(交互)正在解析响应内容
- 4-(完成)响应内容解析完成，可以在客户端调用

xhr.status

- 2xx-表示成功处理请求，如 200
- 3xx-表示需要重定向，浏览器直接跳转，如 301（永久重定向），302（临时重定向），304（资源缓存未改变浏览器可以直接读缓存资源）
- 4xx-客户端请求错误，如 404,403
- 5xx-服务器错误

#### 9.2 同源策略和跨域

跨域题目：

- 什么是跨域？（同源策略）
- JSONP
- CORS（服务端支持）

什么是同源策略：

- 发送 ajax 请求时，浏览器要求当前网页和 server 地址必须同源（安全）
- 同源：协议，域名，端口必须一致，否则浏览器会限制

加载图片、css、js 可以无视同源策略

- <img />可用于统计打点，可用第三方服务
- <link /> <script />可使用CDN,CDN一般都是外域
- <script />可实现JSONP

跨域

- 所有的跨域，都必须经过 server 端允许和配合
- 未经 server 端允许就实现跨域，说明有漏洞、危险信号

#### 9.3.JSONP

- <script>可以绕过跨域限制
- 服务器可以拼接任意数据返回，只要符合 html 格式要求
- 所以，<script>可以获得跨域数据，**只要服务端愿意返回**

```html
<script>
  window.abc = function (data) {
    console.log(data);
  };
</script>
<script src="xxx.com/jsonp.js?username=123&callback=abc"></script>
<!-- 返回的内容就是：callback({ name: 123 }) -->
<!-- 可以自定义callback name 以及传参数到服务端 -->
```

jquery 实现 jsonp，原理同上，只是经过 jquery 一层封装

```js
$.ajax({
  url: "xxx.com",
  dataType: "jsonp",
  jsonpCallback: "callback",
  success: function (data) {
    console.log(data);
  },
});
```

CORS-服务器设置 http-header

```
// 第二个参数填写允许跨域的域名，不建议直接写*
response.set("Access-Control-Allow-Oring", "http://localhost:8899")
response.set("Access-Control-Allow-Headers", "X-Requested-With")
response.set("Access-Control-Allow-Methods", "PUT,POST,GET,DELETE,OPTIONS")

// 接收跨域的地址
response.set("Access-Control-Alllow-Credentials", true)
```

实现简易 ajax

```js
function ajax(url) {
  const p = new Promise((resolve, reject) = {
    const xhr = new XMLHttpRequest()
    xhr.open('GET', url, true)
    xhr.onreadystatechange = function() {
      if (xhr.readyState === 4) {
        if (xhr.status === 200) {
          resolve(JSON.parse(xhr.responseText))
        } else if (xhr.status === 404) {
          reject(new Error('404 not found'))
        }
      }
    }
    xhr.send(null)
  })
  return p
}

ajax('http://localhost.com/json.js')
  .then(res => console.log(res))
  .catch(e => {
    console.log(e)
  })
```

ajax 常用插件

- jquery $.ajax
- **fetch**返回的 Promise 不会被标记为 reject，仅当网络故障或请求被阻止的时候才被标记为 reject。fetch 不会从服务端接收 cookie，必须设置 credentials
- axios，基于 XMLHttpRequest 封装，功能全面，支持 promise

### 10.存储

#### cookie

- cookie 设计出来是用于浏览器和 server 的通讯
- 被借用来本地存储
- 可用 document.cookie = ''来修改，每次只能设置一个，相同 key 则修改，不同则追加

缺点：

- 存储大小，最大 4KB
- http 请求时需要发送到服务端，增加请求数据量
- 只能通过 document.cookie = '...'来修改，太过简陋，

#### localStorage 和 sessionStorage

- HTML5 专门为存储而设计，最大可存 5M
- API 简单易用 setItem, getItem, removeItem
- 不会随着 http 请求被发送出去
- localStorage 数据会永久存储，除非代码或手动删除
- sessionStorage 数据只存在于当前会话中，浏览器关闭则清空

描述 cookie, localStorage 和 sessionStorage 区别

- 容量
- API 使用
- 是否会被 http 请求发送到服务器

### http

- http 常见的状态码有哪些？
- http 常见 header 有哪些
- 什么是 Restful API
- 描述一下 http 的缓存机制

#### http 状态码

状态码分类：

- 1xx 服务器收到请求
- 2xx 请求成功 如 200
- 3xx 重定向，如 302
- 4xx 客户端错误，如 404
- 5xx 服务端错误，如 500

常见状态码：

- 200 成功
- 301 永久重定向（配合 location，浏览器自动处理）
- 302 临时重定向（配合 location，浏览器自动处理）
- 304 资源未被修改，可以直接使用浏览器旧的资源
- 404 资源未被找到
- 403 没有权限
- 500 服务器错误
- 501 尚未实施，服务器不具备完成请求的功能
- 502 bad gateway，请求的网关有问题
- 503 service unavailable 服务不可用，服务器目前无法使用
- 504 网关超时，可能服务器之间也有跳转操作，服务端卡住，可能会的导致处理超时

#### http methods

传统的 methods

- get 获取服务器的数据
- post 向服务器提交数据
- 简单的网页功能，就这两个操作

现代的 methods

- get 获取数据
- post 新建数据
- patch/put 更新数据
- delete 删除数据

Restful API

- 是一种新的 API 设计方式，早已推广使用
- 传统 API 设计：把每个 url 当做一个功能
- Restful API 设计： 把每个 url 当做一个唯一的资源

如何设计成一个资源

- 尽量不用 url 参数
  - 传统 API 设计：/api/list?pageIndex=2
  - Restful API 设计：/api/list/2
- 用 method 表示操作类型
  - 传统 API 设计
    ```
    post请求：/api/create-blog
    post请求：/api/update-blog?id=100
    get请求：/api/get-blog?d=200
    ```
  - Restful API 设计
    ```
    post请求： /api/blog
    patch请求： /api/blog/100
    get请求：/api/blog/100
    ```

#### http headers

常见 request headers

- Accept 浏览器可接受的数据格式
- Accept-Encoding 浏览器可接收的压缩算法，如 gzip
- Accept-Language 浏览器可接收的语言，如 zh-CN
- Connection: keep-alive 一次 TCP 连接重复使用
- cookie
- Host 请求域名
- User-Agent (简称 UA)浏览器信息
- Content-type 发送数据的格式，如 application/json

常见 responnse headers

- Content-type 返回数据的格式，如 application/json
- Content-length 返回数据的大小，多少字节
- Content-Encoding 返回数据的压缩算法，如 gzip，即告诉客户端，服务端用了 gzip 算法来压缩资源的
- Set-Cookie

自定义 header：客户端和服务端都能自定义 header，但是需要两端都协商配置好才能读取

```js
// 如axios
headers: { 'X-Requested-With': 'XMLHttpRequest' }
```

缓存相关的 header

- Cache-Control Expires
- Last-Modified If-Modified-Since
- Etag If-None-Match

#### http 缓存

什么是缓存？

- 访问一个新的网站的时候，会请求网站的所有资源，但是第二次访问的时候，为提高加载的速度，浏览器会把网站的一些资源缓存下来。直接访问缓存的资源即可

为什么需要缓存

- 可以提高页面的加载速度，网络请求相比 CPU 的计算，会慢一些，缓存可以减少请求的数量和大小

哪些资源可以被缓存？

- 静态资源（js、css、img）

#### http 强制缓存

Cache-Control

- Response Headers 中，是在服务端控制
- 控制强制缓存的逻辑
- 例如 Cache-Control: max-age=31536000(单位是秒)

cache-control 的值

- max-age
- no-cache 在发布缓存副本之前，强制要求缓存把请求提交给原始服务器进行验证(协商缓存验证)
- no-store 缓存不应存储有关客户端请求或服务器响应的任何内容，即不使用任何缓存。
- private 响应只能被单个用户缓存，不能作为共享缓存
- public 响应可以被任何对象（包括：发送请求的客户端，代理服务器，等等）缓存

关于 Expires

- 同在 Response Headers 中
- 同为控制缓存过期
- 现在已经被 Cache-Control 代替了

#### http 协商缓存（对比缓存）

- 服务端缓存策略，由服务端来判断这个资源是否能被缓存，再使用缓存之前，去服务端判端客户端资源，是否和服务端资源一样
- 一致返回 304，否则返回 200 和最新的资源

浏览器---->初次请求---->服务器 -----> 返回资源和资源标识

浏览器---->再次请求，带着资源标识 -----> 服务器 ----> 返回 304，或者返回资源和新的资源标识

资源标识

- 在 Response Headers 中
- Last-Modified 资源的最后修改时间
- Etag 资源的唯一标识（一个字符串，类似人类的指纹）
- 会优先使用 Etag
- Last-Modified 只能精确到秒级
- 如果资源被重复生成，而内容不变，则 Etag 更精确

```
                                                |--N-->向服务器发起http请求--->服务器返回请求资源---->页面呈现
                                                |
http请求--->有缓存--->缓存是否过期--Y-->有Etag和Last-Modified--Y-->向服务器发起http请求带If-None-Match、If-Modified-Since字符---->服务器判定缓存是否可用--304-->读取缓存--->页面呈现
                          |                                                                                                            |
                          N                                                                                                           200
                          |----> 读取缓存（强缓存）---->页面呈现                                                                          |---->服务器返回请求资源---->页面呈现
```

#### 三种刷新操作

- 正常操作：地址栏输入 url、跳转链接、前进后退等
- 手动刷新：F5，点击刷新按钮，右击菜单刷新
- 强制刷新：ctrl+F5

不同刷新操作，不同的缓存策略

- 正常操作：强制缓存有效，协商缓存有效
- 手动刷新：强制缓存失效，协商缓存有效
- 强制刷新：强制缓存失效，协商缓存失效

### 11.开发环境

生成 ssh key

cat ~/.ssh/id_rsa.pub

#### 11.1 开发环境知识点

- git
- 调试工具
- 抓包
- webpack babel
- linux 常用命令

#### 11.2 git 常用命令

- git add .
- git checkout xxx // 还原到某个版本或者切换分支
- git commit -m "xxx" // 提交一个记录
- git push origin master // 推送到远程分支
- git pull origin master // 从某个远程分支更新
- git branch 查看当前分支
- git checkout -b xxx / git checkout xxx 切换分支
- git merge xxx 合并分支，把 xxx 合并到当前分支上
- git fetch 拉取分支
- git stash 贮藏 / gti stash pop

### 抓包

- fiddler
- charles

#### webpack 和 babel

- ES6 模块化，浏览器暂不支持
- ES6 语法，浏览器并不完全支持
- 压缩代码，整合代码，以让网页更快加载

webpack 用于文件的打包构建

babel 则是用编译 ES6 新特性，兼容低版本浏览器

模块化

export 多个模块

```js
export function fn() {
  console.log("this is fn");
}

export const name = "xxx";
```

```js
function fn() {
  console.log("this is fn");
}

const name = "xxx";

export { fn, name };
```

```js
import { fn, name } from "a.js";
```

export 一个模块

```js
const batman = {
  name: "bruce",
};
export default batman;
```

```js
import batman from "a.js";
console.log(batman.name);
```

#### linux 常用命令

- ssh work@192.168.0.1 // 登录远程服务器
- ls // 查看目录文件
- ls -a // 查看所有文件包括隐藏文件
- ll // 列表形式展示文件
- ll dist/ // 查看某个目录下的文件
- clear 清屏
- mkdir // 新建目录
- rm -rf dist/ // 删除某个目录下的所有文件 r 递归调用 f 强制删除
- mv index.html index1.html // 修改某个文件名的名称
- mv index.html ../index.html // 也可以移动某个文件
- cp index.html index1.html // 复制某个文件
- touch index.js // 创建一个文件
- vi index.js // 可以进入编辑模式 输入 i 编辑，esc 退出编辑，w 保存，q 退出，q!强制退出
- cat index.js // 查看文件内容
- grep "babel" package.json // 在某个文件内查找字符
- head package.json // 查看前面几行
- tail package.json // 查看后面几行

### 12.运行环境

#### 页面加载和渲染过程

知识点：

- 页面资源加载的形式
- 页面加载的过程
- 渲染页面的过程

资源的形式：

- html 代码
- 媒体资源，如图片，视频等
- js css

加载过程：

- DNS 域名解析：域名->IP 地址，大型公司会分区代理
- 浏览器根据 IP 地址向服务器发起 http 请求
  - 发起⼀个HTTP请求之后，浏览器⾸先查找缓存，如果缓存没有命中，那么继续发起DNS请求获取IP地址，
  然后利⽤IP地址和服务器端建⽴TCP连接，再发送HTTP请求，等待服务器响应；不过，如果服务器响应头
  中包含了重定向的信息，那么整个流程就需要重新再⾛⼀遍。这就是在浏览器中⼀个HTTP请求的基础流
- 服务器处理 http 请求，并返回浏览器

渲染过程-1

- 根据 html 代码生成 DOM Tree
- 根据 css 代码生成 CSSOM
- 将 DOM Tree 和 CSSOM 整合成 Render Tree

渲染过程-2：

- 根据 Render Tree 渲染页面
- 遇到 script 则暂停渲染，优先并执行 JS 代码，直至完成再继续
- 直至 Render Tree 渲染完成

其实回答很简单(俗称天龙八步) 
1.根据域名，进行DNS域名解析； 
2.拿到解析的IP地址，建立TCP连接； 
3.向IP地址，发送HTTP请求； 
4.服务器处理请求； 
5.返回响应结果；  
6.关闭TCP连接； 
7.浏览器解析HTML； 
8.浏览器布局渲染；



为何把 css 放在 head？

如果放在底部，页面结构可能在加载 css 的时候会发生变化，如果放在头部，render tree 会结合 cssom 一起渲染

图片不会阻塞页面加载过程

Window.onload 和 DOMContentLoaded

```js
window.addEventListener("load", function () {
  // 页面全部资源加载完才会执行，包括图片，视频等，包括iframe
});

window.addEventListener("DOMContentLoaded", function () {
  // DOM渲染完就会执行，此时图片，视频有可能还没有加载完
});
```

渲染流⽔线⼤总结：从HTML到DOM、样式计算、布局、图层、绘制、光栅化、合成和显⽰

1. 渲染进程将HTML内容转换为能够读懂的DOM树结构。
2. 渲染引擎将CSS样式表转化为浏览器可以理解的styleSheets，计算出DOM节点的样式。
3. 创建布局树，并计算元素的布局信息。
4. 对布局树进⾏分层，并⽣成分层树。
5. 为每个图层⽣成绘制列表，并将其提交到合成线程。
6. 合成线程将图层分成图块，并在光栅化线程池中将图块转换成位图。
7. 合成线程发送绘制图块命令DrawQuad给浏览器进程。
8. 浏览器进程根据DrawQuad消息⽣成⻚⾯，并显⽰到显⽰器上。

浏览器原理21课：
`优化页面加载时间`

通过浏览器network查看资源请求的情况，主要关注三个阶段Queue，Waiting(TTFB)以及Content Download阶段

Waiting阶段称为第一字节时间，TTFB反映了服务端响应速度的重要指标，对服务器来说，TTFB时间越短，就说明服务器响应越快

Content Download阶段是接收到第⼀个字节之后，进⼊陆续接收完整数据的阶段

页面加载慢可能由以下原因导致：
1. 排队（Queuing）时间过久

域名分片技术，浏览器器为每个域名最多维护6个TCP连接导致，可以尽量让1一个站点下的资源放在多个域名下。

还可以把站点升级到HTTP2，HTTP2已经没有每个域名最多维护6个TCP连接的显示

2. 第⼀字节时间（TTFB）时间过久
- 服务器⽣成⻚⾯数据的时间过久
- ⽹络的原因。
- 发送请求头时带上了多余的⽤⼾信息。

解决方案：
- 提⾼服务器的处理速度，⽐如通过增加各种缓存的技术；
- 针对第⼆种⽹络问题，你可以使⽤CDN来缓存⼀些静态⽂件；
- 第三种，你在发送请求时就去尽可能地减少⼀些不必要的Cookie数据信息。

3. Content Download时间过久

单个请求的Content Download花费了⼤量时间，有可能是字节数太多的原因导致的

这时候你就需要减少⽂件⼤⼩，⽐如压缩、去掉源码中不必要的注释等⽅法。



`从浏览器地址栏输入url到请求返回发生了什么`

我回答了首先会进行 url 解析，根据 dns 系统进行 ip 查找。

话音刚落，此时一位喜欢修福报的公司的大佬打断了我，说 url 为啥要解析，dns 查询规则是什么？我一听就心里想，不按套路出牌啊，网上一般都没问这两个问题，心里再一想，俗话说，万事开头难，扛过这一波，答出来，就是阳光明媚，万物骚动的春天！

> 先说为什么 url 要解析（也就是编码)

- 我回答大概内容是：因为网络标准规定了 URL 只能是字母和数字，还有一些其它特殊符号（-\_.~ ! \* ' ( ) ; : @ & = + $ , / ? # [ ]，特殊符号是我下来查的资料，实在背不住这么多，比较常见的就是不包括百分号和双引号），而且如果不转义会出现歧义，比如 http:www.baidu.com?key=value,假如我的key本身就包括等于=符号，比如ke=y=value，就会出现歧义，你不知道=到底是连接key和value的符号，还是说本身key里面就有=。
- 大佬接着毒打我说，那 url 编码的规则是什么呢，我说 utf-8
- 大佬接着穷追不舍，为啥是 utf-8 呢，所有浏览器都是这样吗？中文的话用 gb2312 编码吗，还有就是万一浏览器不是你说的这样统一用 utf-8，你怎么保证都是 utf-8 的编码?
- 我支支吾吾的说，我了解的大概是这样，不太清楚, 应该和 html 本身的编码格式有关，然后怎么保证 utf-8 的编码，我觉得可以用 encodeURIComponent
- 大佬说 encodeURIComponent 比 encodeURI 有什么区别?
- 区别就是 encodeURIComponent 编码范围更广，适合给参数编码，encodeURI 适合给 URL 本身（locaion.origin）编码,当然项目里一般都是用 qs 库去处理

> 然后说说 dns 解析流程，并且 html 如何做 dns 优化

首先 dns 这个属于很久以前在计算机网络谢希仁版看到过了，有一些细节忘了，但是大致流程是记得的。比如说查询一个网址为：www.baidu.com

- 浏览器中输入https://www.baidu.com 域名，操作系统会先查 hosts 件是否有记录，有的话就会把相对应映射的 IP 返回。
- hosts 文件没有就去查本地 dns 解析器有没有缓存。（这个我没答上来）
- 然后就去找我们计算机上配置的 dns 服务器上有或者有缓存，就返回
- 还没有的话就去找根 DNS 服务器(全球 13 台，固定 ip 地址)，然后判断.com 域名是哪个服务器管理，如果无法解析，就查找.baidu.com 服务器是否能解析，直到查到www.baidu.com的IP地址

注:后面查资料才发现 dns 查询有两种模式，一种是转发模式，一种是非转发模式，我上面说的 4 是非转发模式。

前端的 dns 优化，可以在 html 页面头部写入 dns 缓存地址，比如

```html
<meta http-equiv="x-dns-prefetch-control" content="on" />
<link rel="dns-prefetch" href="http://bdimg.share.baidu.com" />
```

终于抗过了第一轮的猛问，接着我继续说从浏览器地址栏输入 url 到请求返回发生了什么

查找到 IP 之后，就是 TCP 协议的三次握手（以及后面会涉及到四次分手）

我刚恢复节奏，准备侃侃而谈，修福报的大佬再次打断了我，说三次握手，为啥两次不行，顺便说一下 3 次握手发生了什么。

我去，大意了，没有闪，这是不是说我每说一句都要夹杂着各种问题，太难了啊！！！

没有办法，继续回答大佬，我说我先回答三次握手发生的事情吧，简答来说：

- 第一次握手：主机 A 发送位码为 SYN ＝ 1 的 TCP 包给服务器，并且随机产生一个作为确认号（这是 tcp 包的一部分），主机 B 收到 SYN 码后直到 A 要求建立连接;

- 第二次握手：主机 B 收到请求后，向 A 发送确认号（主机 A 的 seq+1），syn=1，seq = 随机数 的 TCP 包；

- 主机 A 收到后检查确认号是否正确，即第一次 A 发送的确认号是否+1 了，以及位码 ack 是否为 1，若正确，主机 A 会再发送确认号(主机 B 的 seq+1)，ack=1，主机 B 收到后确认 seq 值与 ack=1 则连接建立成功。

接着补上小问题为什么两次握手不行，因为第二次握手，主机 B 还不能确认主机 A 已经收到确认请求，也是说 B 认为建立好连接，开始发数据了，结果发出去的包一直 A 都没收到，那攻击 B 就很容易了，我专门发包不接收，服务器很容易就挂了。

> 接着，大佬说出个加分题，我看你不是科班出身，能答多少是多少。问题是,从网卡把数据包传输出去到服务器发生了什么，提示我 OSI 参考模型

我一听，好嘛，这不是计算机网络的知识吗，幸亏之前看过书，但也是好久以前看过了，只能凭借自己的理解解答了。

- 我说，先从局域网把数据发送到公司的交换机（如果交换机没有缓存本地 mac 地址和 IP 地址的映射，此时会通过 ARP 协议来获得），交换机的好处是可以隔离冲突域（因为以太网用的是 CSMA/CD 协议,这个协议规定网线上同一时刻只能有一台机器发送数据），这样就可以不仅仅同一时刻只有一台机器发送网络包了
- 然后交换机再将数据发送到路由器，路由器相当于公司网关（我们公司小），路由器具有转发和分组数据包的功能（路由器通过选定的路由协议会构造出路由表，同时不定期的跟相邻路由器交换路由信息），然后这算是经过了物理层，数据链路层（以太网）,开始到网络层进行数据转发了
- 然后路由器转发 IP 数据报，一般公司的 IP 地址都会经过 NAT 转换，让内网的 ip 也能够访问外网，我们公司我注意了一下是 192.168 打头的内网 ip 地址。通过路由器的分组传输，所有数据到达服务器。
- 然后服务器的上层协议传输层协议开始发挥作用，根据 tcp 包里的端口号，让服务器特定的服务来处理到来的数据包，并且 tcp 是面向字节流的(tcp 有四大特性，可靠传输、流量控制、拥塞控制、连接管理)，所以我们 node 的 request 对象，它的监听事件 data 事件为什么要用字符串一起拼接起来呢（buffer），就是因为 tcp 本身就是字节流，request 对象使用的 data（http 层面）是 tcp 传来的数据块。
- 最后数据由传输层转交给应用层，也就是 http 服务（或者 https），后端经过一系列逻辑处理，返回给前端数据

> 答完这里，我说大佬我只知道大概的流程，具体细节我不是很清楚，但自己后面会补上。。。

大佬让我继续，我就接着 3 次握手之后接着说道，建立完链接，就该请求 html 文件了，如果 html 文件在缓存里面浏览器直接返回，如果没有，就去后台拿

刚说到缓存，立马就有一种不详的预感，果不其然大佬先让把缓存解释一下。缓存这种问烂的问题，本以为能轻松应对，结果还是被问了个满头包。。。。

我说的大概意思是:

- 浏览器首次加载资源成功时，服务器返回 200，此时浏览器不仅将资源下载下来，而且把 response 的 header(里面的 date 属性非常重要，用来计算第二次相同资源时当前时间和 date 的时间差)一并缓存;

- 下一次加载资源时，首先要经过强缓存的处理，cache-control 的优先级最高，比如 cache-control：no-cache,就直接进入到协商缓存的步骤了，如果 cache-control：max-age=xxx,就会先比较当前时间和上一次返回 200 时的时间差，如果没有超过 max-age，命中强缓存，不发请求直接从本地缓存读取该文件（这里需要注意，如果没有 cache-control，会取 expires 的值，来对比是否过期），过期的话会进入下一个阶段，协商缓存

- 协商缓存阶段，则向服务器发送 header 带有 If-None-Match 和 If-Modified-Since 的请求，服务器会比较 Etag，如果相同，命中协商缓存，返回 304；如果不一致则有改动，直接返回新的资源文件带上新的 Etag 值并返回 200;

- 协商缓存第二个重要的字段是，If-Modified-Since，如果客户端发送的 If-Modified-Since 的值跟服务器端获取的文件最近改动的时间，一致则命中协商缓存，返回 304；不一致则返回新的 last-modified 和文件并返回 200;

果不其然，大佬问了一些缓存不常问的，首先就是问我知道什么是 from disk cache 和 from memory cache 吗，什么时候会触发？

- 我说强缓存会触发，这两种，具体什么行为不知道,大概内容如下：

```
1、先查找内存，如果内存中存在，从内存中加载；
2、如果内存中未查找到，选择硬盘获取，如果硬盘中有，从硬盘中加载；
3、如果硬盘中未查找到，那就进行网络请求；
4、加载到的资源缓存到硬盘和内存；
```

接着大佬又问知道什么是启发式缓存吗，在什么条件下触发？

这个问题给我的感觉就两个字，懵逼！然后如实回答不知道。（查了下资料大概如下）

启发式缓存:

如果响应中未显示 Expires，Cache-Control：max-age 或 Cache-Control：s-maxage，并且响应中不包含其他有关缓存的限制，缓存可以使用启发式方法计算新鲜度寿命。通常会根据响应头中的 2 个时间字段 Date 减去 Last-Modified 值的 10% 作为缓存时间。

```
// Date 减去 Last-Modified 值的 10% 作为缓存时间。
// Date：创建报文的日期时间, Last-Modified 服务器声明文档最后被修改时间
  response_is_fresh =  max(0,（Date -  Last-Modified)) % 10
```

接着回答，我说返回 html 之后，会解析 html,这部分知识我提前准备过，但是答的不是很详细，大概意思就是 cssom + domTree = html,然后布局和绘制

- 构建 DOM 树(DOM tree)：从上到下解析 HTML 文档生成 DOM 节点树（DOM tree），也叫内容树（content tree）；

- 构建 CSSOM(CSS Object Model)树：加载解析样式生成 CSSOM 树；

- 执行 JavaScript：加载并执行 JavaScript 代码（包括内联代码或外联 JavaScript 文件）；

- 构建渲染树(render tree)：根据 DOM 树和 CSSOM 树,生成渲染树(render tree)；

- 渲染树：按顺序展示在屏幕上的一系列矩形，这些矩形带有字体，颜色和尺寸等视觉属性。

- 布局（layout）：根据渲染树将节点树的每一个节点布局在屏幕上的正确位置；

- 绘制（painting）：遍历渲染树绘制所有节点，为每一个节点适用对应的样式，这一过程是通过 UI 后端模块完成；

接着面试官问我一些页面渲染层的一些优化手段，大概如下：

- HTML 文档结构层次尽量少，最好不深于六层；
- 脚本尽量后放，放在前即可；
- 少量首屏样式内联放在标签内；
- 样式结构层次尽量简单；
- 在脚本中尽量减少 DOM 操作，尽量缓存访问 DOM 的样式信息，避免过度触发回流；
- 减少通过 JavaScript 代码修改元素样式，尽量使用修改 class 名方式操作样式或动画；
- 动画尽量使用在绝对定位或固定定位的元素上；
- 隐藏在屏幕外，或在页面滚动时，尽量停止动画；
- 尽量缓存 DOM 查找，查找器尽量简洁；
- 涉及多域名的网站，可以开启域名预解析

最后面试官问我，如何诊断页面渲染时各个性能指标，我大概说了，通过 chrome 浏览器的工具，比如看网络请求情况的 network，还有看页面渲染情况的 perfermance，面试下来自己查了一些资料，比如知乎的这篇文章，我觉得写的很详细，以下是摘抄部分，我打算以后有机会自己总结一篇。

[zhuanlan.zhihu.com/p/105561186](zhuanlan.zhihu.com/p/105561186)

`escape,encodeURI,encodeURIComponent有什么区别`

一、escape 和它们不是同一类

简单来说，escape 是对字符串(string)进行编码(而另外两种是对 URL)，作用是让它们在所有电脑上可读。

编码之后的效果是%XX 或者%uXXXX 这种形式。

其中 ASCII 字母 数字 @\*/+ 这几个字符不会被编码，其余的都会。

最关键的是，当你需要对 URL 编码时，请忘记这个方法，这个方法是针对字符串使用的，不适用于 URL。

二、最常用的 encodeURI 和 encodeURIComponent

对 URL 编码是常见的事，所以这两个方法应该是实际中要特别注意的。

它们都是编码 URL，唯一区别就是编码的字符范围，其中

encodeURI 方法不会对下列字符编码**ASCII 字母 数字 ~!@#$&\*()=:/,;?+'**

encodeURIComponent 方法不会对下列字符编码**ASCII 字母 数字 ~!\*()'**

所以 encodeURIComponent 比 encodeURI 编码的范围更大。

实际例子来说，encodeURIComponent 会把 http:// 编码成 http%3A%2F%2F 而 encodeURI 却不会。

三、最重要的，什么场合应该用什么方法

1、如果只是编码字符串，不和 URL 有半毛钱关系，那么用 escape。

2、如果你需要编码整个 URL，然后需要使用这个 URL，那么用 encodeURI。

比如

```js
encodeURI("http://www.cnblogs.com/season-huang/some other thing");
```

编码后会变为

```js
"http://www.cnblogs.com/season-huang/some%20other%20thing";

```

其中，空格被编码成了%20。但是如果你用了 encodeURIComponent，那么结果变为

```js
"http%3A%2F%2Fwww.cnblogs.com%2Fseason-huang%2Fsome%20other%20thing";

```

看到了区别吗，连 "/" 都被编码了，整个 URL 已经没法用了。

3、当你需要编码 URL 中的参数的时候，那么 encodeURIComponent 是最好方法。

```js
var param = "http://www.cnblogs.com/season-huang/"; //param为参数
param = encodeURIComponent(param);
var url = "http://www.cnblogs.com?next=" + param;
console.log(url); //"http://www.cnblogs.com?next=http%3A%2F%2Fwww.cnblogs.com%2Fseason-huang%2F"
```

> The URI methods encodeURI(), encodeURIComponent(), decodeURI(), and decodeURIComponent() replace the escape() and unescape() methods, which are deprecated in the ECMA-262 third edition.

#### 性能优化

性能优化原则：

- 多使用内存、缓存或其他方法
- 减少 CPU 计算量，减少网络加载耗时
- （适用于所有编程的性能优化-空间换时间）

从何入手：

- 让加载更快
- 让渲染更快（代码结构更合理）

让加载更快：

- 减少资源体积：压缩代码
- 减少访问次数：合并代码，SSR 服务端渲染，缓存、css sprites
- 使用更快的网络：CDN

让渲染更快-1

- CSS 放在 head 里，JS 放在 body 最下面
- 尽早开始执行 JS，用 DOMContentLoaded 触发
- 懒加载（图片懒加载，上滑加载更多）
- 对 DOM 查询进行缓存
- 频繁 DOM 操作，合并到一起插入 DOM 结构
- 节流 throttle 防抖 debounce

缓存：url 和文件不变，就会自动触发 http 缓存机制，返回 304，告诉浏览器资源没有改变，直接用缓存即可

防抖 debounce: 使用场景是频繁操作的时候使用

场景：搜索引擎输入框搜索功能

```js
function debounce(fn, delay = 500) {
  let timer = null;
  return function () {
    if (timer) {
      clearTimeout(timer);
    }
    timer = setTimeout(() => {
      fn.apply(this, arguments);
      timer = null;
    }, delay);
  };
}

const input = document.getElementById("input1");
input.addEventListener(
  "keyup",
  debounce(function () {
    console.log(input.value);
  }, 600)
);
```

节流 throttle：拖拽，可以减少触发

场景：拖拽一个元素，要随时拿到该元素被拖拽的位置，可以减少触发次数，每隔 100ms 再触发

```js
function throttle(fn, delay = 100) {
  let timer = null;
  return function () {
    if (timer) {
      return;
    }
    timer = setTimeout(() => {
      fn.apply(this, arguments);
      timer = null;
    }, delay);
  };
}

const div = document.getElementById("div");
div.addEventListener(
  "drag",
  throttle(function (e) {
    console.log(e.offsetX, e.offsetY);
  }, 200)
);
```

#### 安全

常见的 Web 前端攻击方式：

- XSS 跨站请求攻击
- XSRF 跨站请求伪造

XSS 攻击

- 如果一个博客网站，对特殊标签如果没有做转义，这样就可以嵌入<script>脚本
- 不转义发布到前端就会被执行，攻击者就可以轻松执行脚本，获取一些敏感信息，并且发送到自己的服务器上

XSS 预防

- 替换特殊字符，如<变为&lt;,>变为&gt;
- 替换后脚本就不会被执行，并且直接显示
- 前端和后端都要做

npm 包：可以搜 xss

XSRF 攻击（现在已不常见）

- 你在购物，看中一个商品 id 为 100
- 付款的接口是 xxx.com/pay?id=100，但没有任何认证
- 攻击者看中的商品 id 是 200
- 攻击者向你发送一封电子邮件，邮件标题很吸引人
- 但邮件正文隐藏着<img src="xxx.com/pay?id=200">，img 可以跨域，可以把你的登录信息带过去
- 你一查看邮件，就会购买 id 为 200 的商品

XSRF 预防

- 使用 POST 接口，要配合跨域
- 增加验证，例如密码，短信验证，指纹等。

#### 真题

1.var 和 let, const 的区别

- var 是 ES5 语法，let、const 是 ES6 语法，var 有变量提升
- var 和 let 声明的是变量，可以修改，const 声明的是常量，不可以修改
- let 和 const 有块级作用域，var 没有

2.typeof 能判断什么类型

- undefined、string、number、boolean、symbol
- object(注意 typeof null == 'object')
- function

3.列举强制类型转换和隐式类型转换

- 强制：parseInt、parseFloat、toString 等
- 隐式：if、逻辑运算、==、+ 拼接字符串

4.手写深度比较，模拟 loadash isEqual

```js
function isObject(obj) {
  return typeof obj === "object" && obj !== null;
}

function isEqual(obj1, obj2) {
  if (!isObject(obj1) || !isObject(obj2)) {
    // 值类型（注意，参与equal一般不会是函数
    return obj1 === obj2;
  }

  // 如果传入的是同一个对象,直接返回true
  if (obj1 === obj2) {
    return true;
  }

  // 两个都是对象或数组，而且不相等
  // 1.比较两个对象或数组的key长度是否相等
  const obj1Keys = Object.keys(obj1);
  const obj2Keys = Object.keys(obj2);

  if (obj1Keys.length !== obj2Keys.length) {
    return false;
  }

  // 2.以obj1为基准，依次对obj2递归比较
  for (let k in obj1) {
    const res = isEqual(obj1[k], obj2[k]);
    if (!res) {
      return false;
    }
  }
  // 3.全相等
  return true;
}

const obj1 = {
  a: 100,
  b: {
    x: 100,
    y: 200,
  },
};

const obj2 = {
  a: 100,
  b: {
    x: 100,
    y: 200,
  },
};
const arr1 = [1, 2, 3, 4];
const arr2 = [1, 2, 3, 4, 5];
```

5.split()和 join()的区别

- split()可以根据传入的字符，分割数组
- join()可以根据传入的字符，拼接字符串

6.数组 pop, push, unshift, shift 分别是什么？

可以从三个方面描述：

- 功能是什么
- 返回值是什么
- 是否会对原数组造成影响

```js
const arr = [1, 2, 3, 4];

// pop, 返回数组的最后一个元素，对元素有修改
// const popRes = arr.pop()

// push 往数组尾部追加元素，并返回数组的长度
// const pushRes = arr.push(5) // arr.length

// unshift 往数组头部追加元素，并返回数组的长度
// const unshiftRes = arr.unshift(6) // arr.length

// shift 推出数组头部元素，并返回推出元素
// const shiftRes = arr.shift()
```

[扩展]数组的 API，有哪些是纯函数？

纯函数：1.不改变原数组（没有副作用）2.会返回一个新的数组

```js
const arr = [10, 20, 30, 40];

// concat
const arr1 = arr.concat([50, 60, 70]); // [10, 20, 30, 40, 50, 60, 70]

// map
const arr2 = arr.map((num) => num * 10); // [100, 200, 300, 400]

// filter
const arr3 = arr.filter((num) => num > 20); // [30, 40]

// slice
const arr4 = arr.slice(); // [10, 20, 30, 40]相当于深拷贝数组

// 非纯函数
// pop push unshift shift
// some every
// forEach
// reduce
```

7.数组 slice 和 splice 的区别

- 功能区别（slice - 切片， splice - 剪接）
- 参数和返回值
- 是否纯函数

```js
const arr = [10, 20, 30, 40, 50];
// slice纯函数
const arr1 = arr.slice();
const arr2 = arr.slice(1, 4); // 第一参数是其实位置，第二个参数是截止位置 不包含截止元素 [20, 30, 40]
const arr3 = arr.slice(2); // [30, 40, 50]
const arr4 = arr.slice(-3); // [30, 40, 50]

// splice非纯函数 第一个参数起始位置，第二个参数剪接长度
const spliceRes = arr.splice(1, 2, "a", "b", "c"); // arr = [10, 'a', 'b', 'c', 40, 50]
```

8.[10, 20, 30].map(parseInt)

- map 的参数和返回值
- parseInt 的参数和返回值

```js
[10, 20, 30]
  .map(parseInt) // [10, NaN, NaN]

  [
    //等价于
    (10, 20, 30)
  ].map((item, index) => {
    return parseInt(item, index);
  });

// parseInt() 函数可解析一个字符串，并返回一个整数。

// 当参数 radix 的值为 0，或没有设置该参数时，parseInt() 会根据 string 来判断数字的基数。

// 当忽略参数 radix , JavaScript 默认数字的基数如下:

// 如果 string 以 "0x" 开头，parseInt() 会把 string 的其余部分解析为十六进制的整数。
// 如果 string 以 0 开头，那么 ECMAScript v3 允许 parseInt() 的一个实现把其后的字符解析为八进制或十六进制的数字。
// 如果 string 以 1 ~ 9 的数字开头，parseInt() 将把它解析为十进制的整数
```

9.ajax 请求 get 和 post 区别

- get 一般用于查询操作，post 一般用户的提交操作
- get 参数拼接在 url 上，post 放在请求体内（数据体积可更大）
- 安全性：post 易于防止 CSRF
- get请求能缓存，post不能

  10.函数 call 和 apply 的区别

```js
fn.call(this, p1, p2, p3);
fn.apply(this, arguments); // 第二参数传入数据，集合，类数组元素
```

11.事件代理（委托）是什么？

通过事件冒泡的机制，可以将多个相同元素的事件绑定，通过他们的父元素来绑定。这样可以减少内存消耗，以及代码更加简洁

12.闭包是什么，有什么特性，有什么负面影响

- 回顾作用域和自由变量
- 回顾闭包应用场景：作为参数被传入，作为返回值被返回
- 回顾：自由变量的查找，要在函数定义的地方（而非执行的地方）
- 影响：变量会常驻内存，得不到释放，闭包不能乱用

  13.如何阻止事件冒泡和默认行为

```js
event.stopPropagation();
event.preventDefault();
```

14.查找、添加、删除、移动 DOM 元素

- 查找：getElementById、getElementByTagName、querySelector、querySelectorAll
- 添加：appendChild
- 删除：removeChild
- 移动：appendChild

15.减少 DOM 操作

根据浏览器的渲染机制，如果 DOM 结构可能会导致重排或重绘，浏览器都会重新执行渲染流程，

当我们插入多个相同元素时，我们先创建一个代码片段，此时代码片段并不会渲染，等收集完成后再一次性追加到 DOM，以此来减少 DOM 操作

16.解释 jsonp 原理，为何不是真正的 ajax

- 浏览器的同源策略（服务端没有同源策略）和跨域
- 哪些 html 标签能绕过跨域
- jsonp 原理
- jsonp 是通过 script 标签实现的，ajax 是通过 xhrhttprequest 实现的
- 跨域必须经过服务端的允许

17.doucment load 和 ready 区别

```js
window.addEventListener("load", function () {
  // 页面全部资源加载完才会执行，包括图片，视频等
});

window.addEventListener("DOMContentLoaded", function () {
  // DOM渲染完就会执行，此时图片，视频有可能还没有加载完
});
```

18.== 和 === 区别

- == 会尝试类型转换
- === 严格相等
- 哪些场景才用 ==

  19.函数声明和函数表达式的区别

- 函数声明： function fn() {...}
- 函数表达式：const fn = function() {...}
- 函数声明会在代码执行前预加载，而函数表达式不会

  20.new Object() 和 Object.create()的区别

- {}等同于 new Object()，原型是 Object.prototype
- Object.create(null)没有原型，只有传入对象时才会为实例指定原型
- Object.create({...})可以创建的实例指定原型

  21.关于 this 的场景

```js
const User = {
  count: 1,
  getCount: function () {
    return this.count;
  },
};

console.log(User.getCount()); // 1
const fn = User.getCount;
console.log(fn()); // 1
```

22.关于作用域和自由变量的场景题-1

```js
let i;
for (i = 1; i <= 3; i++) {
  setTimeout(() => {
    console.log(i);
  }, 0);
}
// 输入3次4
```

23.字符串，字符开头，后面字母数字下划线，长度（6-30）

```js
const reg = /^[a-zA-Z]\w{5, 29}$/;
```

24.关于作用域和自由变量的场景题-2

```js
let a = 100;
function test() {
  console.log(a); // 100
  a = 10;
  console.log(a); // 10
}
test();
console.log(a); // 10
```

25.手写字符串 trim 方法，保证浏览器兼容性

```js
if (!String.prototype.trim) {
  String.prototype.trim = function () {
    // zepto underscore的实现方式
    // return this.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '');
    return this.replace(/^\s+/, '').replace(/\s+$/, '')
  };
}
```

26.获取多个数中的最大值

可以用 Math.max 或者 Math.min

```js
function max() {
  const args = Array.prototype.slice.call(arguments);
  let max = 0;

  args.forEach((n) => {
    if (n > max) {
      max = n;
    }
  });
  return max;
}
```

27.如何用 JS 实现继承

- class 继承
- prototype 继承

28.如何捕获 JS 中的异常

- 手动捕获

```js
try {
  // do something
} catch (e) {
  // console.err(e)
} finally {
  // todo
}
```

- 自动捕获

```js
window.onerror = function (message, source, lineNum, ColNum, error) {
  // 1.对于跨域的js，如CDN的，不会有详细的报错
  // 2.对于压缩的js，还要配合sourcemap反查到未压缩的代码的行列
};
```

29.什么是 JSON？

- JSON 是一种数据格式，本质是一段字符串
- json 格式和 js 对象结构一致，对 js 语言更友好
- window.JSON 是一个全局对象：JSON.stringify、JSON.parse
- 在 json 普及之前，ajax 实际上是用 xml 作为上传格式
- json 文件的 key 和 value 都必须用双引号括起来，与 js 中的 json 对象不一样

  30.获取当前页面 url 的参数

- 传统方式，查找 location.search

```js
function query(name) {
  const search = location.search.substr(1);

  const reg = new RexExp(`(^|&)${name}=([^&]*)(&|$)`, "i");

  const res = search.match(reg);

  if (res === null) {
    return null;
  }
  return res[2];
}
```

- 新 API，URLSearchParams

```js
function query(name) {
  const search = location.search;
  const p = new URLSearchParams(search);
  return p.get(name);
}
```

31.将 url 参数解析为 JS 对象

- 传统方式，查找 location.search

```js
function query() {
  const search = location.search.substr(1);
  const res = {};
  search.split("&").forEach((item) => {
    const arr = item.split("=");
    const key = arr[0];
    const value = arr[1];
    res[key] = value;
  });
  return res;
}
```

- 新 API，URLSearchParams

```js
function query() {
  const search = location.search;
  const p = new URLSearchParams(search);
  const res = {};
  p.forEach((val, key) => {
    res[key] = val;
  });
  return res;
}
```

32.手写 flatern 考虑多层级

如果不考虑多层级，可以使用一下方式，不适用超过三层以上层级需要递归调用

```js
const arr = [10, 20, [30, 40], 50]
Array.prototype.concat.apply([], arr)
Array.prototype.concat.call([], 10, 20, [30, 40], 50)
[].concat(10, 20, [30, 40], 50)
```

```js
function flat(arr) {
  // 验证数组中是否还有多层数组
  const isDeep = arr.some((item) => item instanceof Array);
  if (!isDeep) {
    return arr;
  }
  const res = Array.prototype.concat.apply([], arr);
  return flat(res);
}
```

33.数组去重

- 传统方式，遍历元素挨个比较、去重

```js
function unique(arr) {
  const res = [];
  arr.forEach((val) => {
    if (res.indexOf(val) < 0) {
      res.push(val);
    }
  });
  return res;
}
```

- 使用 Set

```js
function unique(arr) {
  const set = new Set(arr);
  return [...set];
}
```

34.手写深拷贝

```js
function deepClone(obj) {
  if (typeof obj !== "object" && obj == null) {
    return obj;
  }

  let res;
  if (obj instanceof Array) {
    res = [];
  } else {
    res = {};
  }

  for (let key in obj) {
    if (obj.hasOwnProperty(key)) {
      res[key] = deepClone(obj[key]);
    }
  }
  return res;
}
```

> 注意，Object.assign 不是深拷贝

```js
const obj = { a: 10, b: 20 };
Object.assign(obj, { c: 30 }); // obj = { a: 10, b: 20, c: 30 }

const obj1 = Object.assign({}, obj, { d: 40 });
// obj1 = { a: 10, b: 20, c: 30, d: 40 }
```

35.介绍 RAF requestAnimationFrame

- 想动画流畅，更新频率要 60 帧/S,即 16.67ms 更新一次视图
- setTimeout 要手动控制，requestAnimationFrame 则浏览器会自动控制
- 后台标签或 iframe 隐藏中，RAF 会停止，setTimout 不会停止

```js
// setTimeout
const $div1 = $("#div1");
let curWidth = 100;
const maxWidth = 640;

function animate() {
  curWidth += 3;
  $div1.css("width", curWidth);
  if (curWidth < maxWidth) {
    setTimeout(animate, 16.67);
  }
}
```

```js
// requestAnimationFrame
const $div1 = $("#div1");
let curWidth = 100;
const maxWidth = 640;

function animate() {
  curWidth += 3;
  $div1.css("width", curWidth);
  if (curWidth < maxWidth) {
    window.requestAnimationFrame(animate);
  }
}
```

36.性能优化，从哪几个方面考虑

- 原则：多使用内存，缓存，减少计算，减少网络请求
- 方向：加载页面，页面渲染，页面操作流畅度

## 简历

- 个人信息：姓名、性别、电话、邮箱、籍贯
- 教育经历：
- 专业技能
- 工作经历
- 项目经历
- 博客及开源

## HTML 和 css

`如何理解HTML语义化`

- 让人更容易读懂（增加代码可读性）
- 让搜索引擎更容易读懂（SEO，方便爬虫抓取）
- 例如页面的一段文字，h 标签可以表示文字的标题，p 表示文章的段落，ul、li 表示一段列表
- 如果页面 css 样式加载发生异常，用 div 布的局可能无法正确显示页面内容，用语义化的标签，由于浏览器会给这些不同标签默认一些样式，所以更加看出页面布局结构

`有哪些块级元素和内联元素`

- 块级元素会独占一行，内联元素会按顺序排列，知道页面换行
- display: block/table,如 div、h1、h2、table、ul、ol、p 等
- display: inline/inline-block, 如 span、img、input、button 等

`盒模型宽度怎么计算`

- offsetWidth = (内容宽度 + 内边距 + 边框), 无外边距
- box-sizing: border-box 可以改变盒模型的计算方式，offsetWidth = width

`margin纵向重叠问题`

- 相邻元素的 margin-top 和 margin-bottom 会发生重叠，以大的外边框为主
- 空白内容也会发生重叠

`margin负值问题`

- margin-top 和 margin-left 为负值，元素会向上、向左移动
- margin-right 负值，元素自身不影响，右侧元素会向左偏移
- margin-bottom 负值，元素自身不影响，下方元素会向上偏移

`BFC理解与应用`

- 什么是 BFC？BFC，即 Block format context，块级格式上下文
- 一块独立的渲染区域，内部元素渲染不会影响边界以外元素
- 形成 BFC 常见条件：
  - float 不是 none
  - position 是 absolute 或 fixed
  - overflow 不是 visible
  - display 是 flex inline-block 等
- BFC 常见应用：
  - 清除浮动

`如何实现圣杯布局和双飞翼布局`

- 圣杯布局和双飞翼布局的目的：
  - 三栏布局，中间一栏最先加载和渲染（内容最重要）
  - 两侧内容固定，中间内容随宽度自适应
  - 一般用于 PC 页面
- 技术总结：
  - 使用 float 布局
  - 两侧使用 margin 负值，以便和中间内容横向重叠
  - 防止中间内容被两侧覆盖，一个使用 padding，一个使用 margin

`圣杯布局`

```html
<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>圣杯布局</title>
    <style type="text/css">
      body {
        min-width: 550px;
      }
      #header {
        text-align: center;
        background-color: #f1f1f1;
      }

      #container {
        padding-left: 200px;
        padding-right: 150px;
      }
      #container .column {
        float: left;
      }

      #center {
        background-color: #ccc;
        width: 100%;
      }
      #left {
        position: relative;
        background-color: yellow;
        width: 200px;
        margin-left: -100%;
        right: 200px;
      }
      #right {
        background-color: red;
        width: 150px;
        margin-right: -150px;
      }

      #footer {
        text-align: center;
        background-color: #f1f1f1;
      }

      /* 手写 clearfix */
      .clearfix:after {
        content: "";
        display: table;
        clear: both;
      }
    </style>
  </head>
  <body>
    <div id="header">this is header</div>
    <div id="container" class="clearfix">
      <div id="center" class="column">this is center</div>
      <div id="left" class="column">this is left</div>
      <div id="right" class="column">this is right</div>
    </div>
    <div id="footer">this is footer</div>
  </body>
</html>
```

`双飞翼布局`

```html
<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>双飞翼布局</title>
    <style type="text/css">
      body {
        min-width: 550px;
      }
      .col {
        float: left;
      }

      #main {
        width: 100%;
        height: 200px;
        background-color: #ccc;
      }
      #main-wrap {
        margin: 0 190px 0 190px;
      }

      #left {
        width: 190px;
        height: 200px;
        background-color: #0000ff;
        margin-left: -100%;
      }
      #right {
        width: 190px;
        height: 200px;
        background-color: #ff0000;
        margin-left: -190px;
      }
    </style>
  </head>
  <body>
    <div id="main" class="col">
      <div id="main-wrap">this is main</div>
    </div>
    <div id="left" class="col">this is left</div>
    <div id="right" class="col">this is right</div>
  </body>
</html>
```

`手写clearfix`

```css
.clearfix::after {
  content: "";
  display: table;
  clear: both;
}
.clearfix {
  *zoom: 1; /*兼容ie模式*/
}
```

`flex布局`

- flex-direction 主轴的方向
- justify-content 主轴对齐方式
- align-items 纵轴对齐方式
- flex-wrap 是否换行
- align-self 子元素对齐方式

```html
<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>flex 画骰子</title>
    <style type="text/css">
      .box {
        width: 200px;
        height: 200px;
        border: 2px solid #ccc;
        border-radius: 10px;
        padding: 20px;

        display: flex;
        justify-content: space-between;
      }
      .item {
        display: block;
        width: 40px;
        height: 40px;
        border-radius: 50%;
        background-color: #666;
      }
      .item:nth-child(2) {
        align-self: center;
      }
      .item:nth-child(3) {
        align-self: flex-end;
      }
    </style>
  </head>
  <body>
    <div class="box">
      <span class="item"></span>
      <span class="item"></span>
      <span class="item"></span>
    </div>
  </body>
</html>
```

`absolute和relative分别依据什么定位`

- relative 会依据自身定位
- absolute 依据最近一层的定位元素来定位

定位元素：

- 设置了 absolute、relative、fixed 的元素
- body

`居中对齐有哪些实现方式`

水平居中：

- inline 元素：text-align: center
- block 元素：margin: auto
- absolute 元素：left 50% + margin-left 负值

垂直居中：

- inline 元素：line-height 的值等于 height 的值
- absolute 元素：top 50% + margin-top 负值
- absolute 元素：transform(-50%, -50%)
- absolute 元素：top、right、bottom、left = 0 + margin：auto
- flex 布局：justify-content: center align-items: center

`line如何继承`

- 写具体数值，如 30px，则继承该数值
- 写比例，如 2 / 1.5，则继承该比例，即当前元素的 font-size \* 该比例 = line-height
- 写百分比，如 200%，则继承计算出来的数值，即父元素的 font-size \* 200% = 子元素的继承的 line-height

`rem是什么`

rem 是一个长度单位

- px，绝对长度单位，常用
- em，相对长度单位，相对父元素，不常用
- rem，相对长度单位，相对根元素，常用语响应式布局

`响应式布局的常用方案`

- media-query，根据不同的屏幕设置根元素的 font-size
- rem，基于根元素的相对定位，缺点：需要根据不同设备提前设置好 media-query，不能直接通过程序自动判断

```css
@media only screen and (max-width: 374px) {
  /* iphone5 或者更小的尺寸，以 iphone5 的宽度（320px）比例设置 font-size */
  html {
    font-size: 86px;
  }
}
@media only screen and (min-width: 375px) and (max-width: 413px) {
  /* iphone6/7/8 和 iphone x */
  html {
    font-size: 100px;
  }
}
@media only screen and (min-width: 414px) {
  /* iphone6p 或者更大的尺寸，以 iphone6p 的宽度（414px）比例设置 font-size */
  html {
    font-size: 110px;
  }
}
```

`网页视口尺寸`

- window.screen.height 屏幕高度
- window.innerHeight 网页视口高度
- document.body.clientHeight body 高度

`vw/vh`

- vh 网页视口高度的 1/100
- vw 网页视口宽度的 1/100
- vmax 取两者最大值，vmin 取两者最小值
- window.innerHeight === 100vh, window.innerWidth === 100vw

[https://juejin.cn/post/6844904116552990727](https://juejin.cn/post/6844904116552990727)
