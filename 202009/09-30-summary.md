## 2020-09-30

### 什么是闭包？

要理解闭包，需要结合作用域链来理解。

在每个执行上下文的变量环境中，都包含着一个外部引用，用来指向外部的执行上下文，可以把这个外部引用叫outer

例如在全局执行上下文声明了一个变量和一个函数，而这个函数在内部对这个变量进行了输出。

当函数调用时时，JavaScript引擎⾸先会在“当前的执⾏上下⽂”中查找该变量，如果在当前的变量环境中没有查找到，那么JavaScript引擎会继续在outer所指向的执⾏上下⽂中查找。

这个查找的链条就称为作⽤域链。

而作⽤域链又是由词法作⽤域决定的。

**词法作⽤域就是指作⽤域是由代码中函数声明的位置来决定的**

正如我刚刚举的例子，在全局作用域声明了一个函数，那词法作⽤域链查找顺序就是：函数的作用域再到全局作用域。

如果理解了以上概念，再来理解闭包容易多。

再举一个例子，在全局声明了一个函数，暂且叫它外部函数，而在这个外部函数内，又声明了一个内部函数，同时这个内部函数还输出了外部声明的一个变量，在外部函数的最后，把这个内部函数return出去。

在JavaScript中，根据词法作⽤域的规则，内部函数总是可以访问其外部函数中声明的变量，当通过调⽤⼀个外部函数返回⼀个内部函数后，即使该外部函数已
经执⾏结束了，但是内部函数引⽤外部函数的变量依然保存在内存中，我们就把这些变量的集合称为闭包。

而这次的查找顺序是：当前执行上下文，再到外部函数的闭包，最后到全局执行上下文。

闭包回收：
- 如果引⽤闭包的函数是⼀个全局变量，那么闭包会⼀直存在直到⻚⾯关闭；但如果这个闭包以后不再使⽤的话，就会造成内存泄漏。
- 如果引⽤闭包的函数是个局部变量，等函数销毁后，在下次JavaScript引擎执⾏垃圾回收时，判断闭包这块内容如果已经不再被使⽤了，那么JavaScript引擎的垃圾回收器就会回收这块内存。
---
### 通用组件处理

一般组件可以分为业务组件和UI组件

UI组件一般也称为基础组件，由于基础组件一般不会耦合业务逻辑，页面会需要经常调用。所以会使用业内比较出名的框架，例如Vuetify、专为移动端设计的vant框架，这样可以大大节省开发效率。

而业务组件可能会涉及比较复杂的功能设计，需要结合产品功能设计来进行抽离复用。

对于交互简单的，例如一些站内的弹框，不需要与其他组件进行交互，一般会把结果，样式及交互逻辑，都封装在一个组件内。这样需要展示组件的页面直接引入组件即可。

对于稍微复杂的业务组件，为了逻辑清晰，可以规定，展示的数据只能从父组件传入子组件，并且事件绑定在父组件上。

对于有特殊场景的需求，可以在组件中预留slot。

---
### vue中watch和computed的区别

computed的定义是计算属性，它会根据依赖的数据动态的显示新的结果。计算结果会被缓存，computed的值在getter执行后是会缓存的，只有在它依赖的属性值改变之后，下一次获取computed的值才会重新调用对应的getter来计算。

computed可以和methods定义方法返回值比较，如果页面中有多个位置调用computed的属性值，那computed只会执行一次，而用methods定义的返回值则会每个地方都会执行一次。

而watcher更像是一个data的数据监听回调。当依赖的data的数据发生变化后并执行相应的回调，回调函数接收newVal和oldVal。

总结一下使用场景就是，两者都会依赖数据的变化，computed更多的用在数据组装或者模板中使用复杂逻辑运算。例如可能是两个字段拼接。

而watcher是监听某个数据发生变化，并且我们需要进行一些其他操作，例如执行异步操作。

---

### Vue如何自定义指令

可以通过Vue.directives方法来注册，Vue.directives定义了几个钩子函数来扩展功能，表示自定义的需要哪个几个阶段触发

我记得有bind，inserted、update、computedUpdated，

bind，只调用一次，绑定时就会触发

inserted，是元素被插入到DOM时触发

update，是指令所在元素更新时触发

computedUpdate，指令所在组件或者子组件更新时触发

unbind，解除绑定时触发

钩子函数会接收4个参数，el和binding，vnode，oldVnode

el是我们当前绑定的元素

binding是传入到指令中的一些配置信息

vnode是当前元素的虚拟节点

oldVnode是上一次的虚拟节点，仅在updated和componentUpdated可用

我自己想到一个场景，可能是产品同事需要在网站埋很多的点，以此来了解用户的点击量，如果一个一个元素的绑定click事件，可能会非常麻烦

所以可以自己定义一套执行规则，自定义一个埋点指令。

如何移除事件绑定，可以通过定义一个全局map，把声明事件回调，按元素保存起来，接着在unbind的时候再进行移除

dataset

---

### Vue常见性能优化

- 函数式组件

  函数式组件和普通的对象类型的组件不同，它不会被看作成一个真正的组件，我们知道在 patch 过程中，如果遇到一个节点是组件 vnode，会递归执行子组件的初始化过程；而函数式组件的 render 生成的是普通的 vnode，不会有递归子组件的过程，因此渲染开销会低很多

  函数式组件也不会有状态，不会有响应式数据，生命周期钩子函数这些东西。

  优化前：
  ```vue
  <template>
    <div class="cell">
      <div v-if="value" class="on"></div>
      <section v-else class="off"></section>
    </div>
  </template>

  <script>
  export default {
    props: ['value'],
  }
  </script>
  ```

  优化后：
  ```vue
  
  <template functional>
    <div class="cell">
      <div v-if="props.value" class="on"></div>
      <section v-else class="off"></section>
    </div>
  </template>
  ```

- 合理使用computed

- v-if 和 v-show

- keepAlive：对于需要频繁进行组件切换的，可以用组件缓存DOM，下次缓存的时候就不会重复渲染直接读取缓存

- 虚拟列表优化：https://cloud.tencent.com/developer/article/1533206
---
### computed的基本原理

![https://segmentfault.com/img/bVbFbA5](https://segmentfault.com/img/bVbFbA5)

![https://segmentfault.com/img/bVbFbtt](https://segmentfault.com/img/bVbFbtt)


可以从三个方便解答这个：

1、computed的初始化，初始化做了什么事情

2、data属性发生变化后，computed会重新计算，是如何实现的

3、computed是如何缓存值的，并如何读取缓存值


https://segmentfault.com/a/1190000022169550
---
### vue $set函数

由于Javascript的限制，Vue不能检测数组和对象的变化，所以才会有Vue set方法

可以分别从对象或数组来讲解，

对于对象

Vue 会在初始化实例时对 property 执行 getter/setter 转化，所以 property 必须在 data 对象上存在才能让 Vue 将它转换为响应式的。因此对新添加或者移除属性是无法检测的。

对于已经创建的实例，Vue 不允许动态添加根级别的响应式 property。但是，可以使用 Vue.set(object, propertyName, value) 方法向嵌套对象添加响应式 property。会接收三个参照，第一个就是vue实例上的嵌套对象，第二个是新增的属性名，第三个是属性值

而对于嵌套对象有多个属性新增的情况，可以先用Object.assign方法先进行合并，再重新赋值给嵌套对象。


而对于数组

1、当你利用索引直接设置一个数组项时
2、当你修改数组的长度时

修改数组长度的情况比较少，主要还是第一种情况比较多

有两种解决方案：

第一种还是使用vue set，这次是传入需要修改的数组，第二个参数是索引，以及第三个参数是需要修改的值

第二种方法是利用调用数组的splice方法，对原来索引位置的值进行替换。实际上，源码也是这样调用

具体原理就是

如果判断是数组，就调用splice方法进行替换。

如果是对象属性，则重新调用defineReactive，转换为响应式对象，并且调用dep.notify触发更新视图。


---
### vuex 原理

Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则管理和操作数据。

例如state用于存储组件中的数据，action用于异步操作，整合多个 mutations，而state的更新只能通过mutations来操作。

具体的原理是：通过vue的插件机制，在vue的生命周期beforeCreated钩子函数执行时，在全局注入vuex的store对象，实现状态共享。

### v-model原理

### 获取数据是在created做好，还是在mounted里做


### 原型和原型链

在javascript中，不像其他语言一样有类的概念，Javascript只有一种结构，就是对象。所以在很久之前就这么一句话，在JS中一切皆对象。

而每个函数默认都有一个显示prototype的属性，这个属性同时还会指向一个对象，这个就是我们的原型对象

当我们用构造函数来new一个实例对象，这个实例对象会有一个隐式的__proto__属性，同时这个属性又指向了构造函数prototype的原型对象。

但刚刚提到原型对象，也有一个隐式的__proto__，也指向一个原型对象，就这样层层向上直到一个对象的原型对象为null，而这样的链子就是所谓的原型链。

而原型链可以帮助我们实现共享属性，当我们创建一个了一个实例对象，并尝试访问该对象上一个属性时，如果该对象存在访问的属性，则会直接返回。如果实例对象不存在该属性，js引擎就会沿着原型链继续查找，

找到了就直接返回，找不到会返回undefined

---
### 继承

- 原型继承

```js
function Person() {}

function Child() {}

Child.prototype = new Person() {}
```

缺点是：
  - 父类引用类型的属性被所有子类实例共享，如果其中一个子类修改了父类的属性，其它子类也会受到影响
  - 创建子类实例时，不能对父类传参数

- 构造函数继承

```js
function Person(name) {
  this.name = name
}

function Child(name) {
  Person.call(this, name)
}
```

优点：
  - 避免了引用类型的属性被所有实例共享，这也会造成额外的一部分开销
  - 可以在子类中向父类传参

缺点：无法继承父类原型上的方法和属性

- 组合继承：即原型继承 + 构造函数继承

```js
function Animal() {}

Animal.prototype.greet = function() {
  console.log('hello')
}

function Dog() {
  Animal.call(this, arguments)
}

Dog.prototype = new Animal()
```
优点：融合原型链继承和构造函数的优点，是 JavaScript 中最常用的继承模式

缺点是，会调用两次父类的构造函数

- 原型式继承：相当于Object.create的模拟实现，需要传入一个对象作为即将创建的对象的原型

```js
function createObject(o) {
  function F() {}
  F.prototype = o
  return new F()
}
```

缺点：包含引用类型的属性值始终都会共享相应的值，这点跟原型链继承一样。

- 寄生组合继承：由于组合继承的两次调用父类构造函数，所以寄生组合的关键是减少一次父类构造函数调用，

  具体的操作就是，再创建一个空的构造函数，并把这个空的构造函数的原型执行父类的构造函数

  再用原型继承，子类的原型继承这个空的构造函数的实例，不过子类原型的contructor会被改掉，可以重新赋值为子类的构造函数

  ```js
  function Parent (name) {
    this.name = name;
    this.colors = ['red', 'blue', 'green'];
  }

  Parent.prototype.getName = function () {
      console.log(this.name)
  }

  function Child (name, age) {
      Parent.call(this, name);
      this.age = age;
  }

  // 关键的三步
  var F = function () {};

  F.prototype = Parent.prototype;

  Child.prototype = new F();
  Child.prototype.contructor = Child

  var child1 = new Child('kevin', '18');

  console.log(child1);
  ```

- extends继承：仅仅是一个语法糖，底层还是通过原型继承
---

### diff算法

diff算法是基于同层级进行比较

如果不是同一节点，会插入新的节点，把旧的节点删除

如果是同一节点，调用 patchVnode()，找节点的差异并更新 DOM

核心的diff算法是updateChildren

在进行同级别节点比较的时候，首先会对新老节点数组的开始和结尾节点设置标记索引，遍历的过程中移动索引

在对开始和结束节点比较的时候，总共有四种情况：

- 旧开始节点 / 新开始节点
- 旧结束节点 / 新结束节点
- 旧开始节点 / 新结束节点
- 旧结束节点 / 新结束节点
---

### 常见攻击 XSS和 CSRF

XSS，即跨站脚本。指的是黑客往HTML文件中或DOM注入恶意脚本，从而在用户浏览页面时利用注入的恶意脚本对用户实施攻击的手段。

恶意脚本可以：窃取Cookie信息，监听用户行为，修改DOM，以及在页面内生成浮窗广告。

常见注入方式：存储型XSS攻击，反射型XSS攻击和基于DOM的XSS攻击（恶意软件劫持）

前两种攻击方式都是利用网站漏洞，

如何预防：
- 服务器对输入脚本进行过滤或转码
- 充分利用CSP：CSP的核⼼思想是让服务器决定浏览器能够加载哪些资源，让服务器决定浏览器是否能够执⾏内联JavaScript代码
  - 限制加载其它域的脚本
  - 禁止向第三方域提交数据
  - 禁止执行内联脚本和未授权的脚本
- 利用httpOnly属性，服务器可以将某些Cookie设置为HttpOnly标志，使⽤HttpOnly标记的Cookie只能使⽤在HTTP请求过程中，所以⽆法通过JavaScript来读取这段Cookie

接着介绍一下CSRF，即跨站请求伪造。指⿊客引诱⽤⼾打开⿊客的⽹站，在⿊客的⽹站中，利⽤⽤⼾的登录状态发起的跨站请求。

有两个关键就是服务器存在漏洞并且用户已登录网站

如何预防：
- 充分利用好Cookie的SameSite属性，从第三方站点发送请求是禁止Cookie的发送
- 验证请求的来源站点 http请求头中的Referer和Origin属性。
- CSRF Token验证。

切记陌生的链接不要点。
---
### https的加密原理

https加密是在http和TCP之间多加了一层安全层，对发起HTTP请求的数据进行加密操作和对接收的http内容进行解密操作。加密的版本有多种，有对称加密和非对称加密

对称加密简单的理解就是浏览器和服务端加密和解密的秘钥是一样的。

所以在发送数据之前，需要协商加解密的方式，这也是https建立安全连接的过程。

具体过程是：
- 浏览器向浏览器发送它所支持的加密套件列表和一个随机数client-random
- 服务器从加密套件列表中选取一个加密套件，然后还会生成一个随机数service-random，并把加密套件和service-random返回给浏览器
- 接着浏览器和服务器分别返回确认信息
- 最后浏览器和服务器通过使用相同的方法将client-random和service-random混合起来生成密钥mater secret，有了密钥和加密套件，双方就可以进行数据加密传输了

缺点是：传输client-random和service-random的过程却是明⽂的，黑客也可以拿到协商的加密套件和双方的随机数，由于加密算法是公开的，这样黑客就可以自己合成密钥，用来破解数据，并进行伪造或篡改数据。

第二种方式使用非对称加密
---

### 跨域资源共享CORS

CORS是一个W3C标准，全称为跨域资源共享

它允许浏览器向跨域源服务器，发起XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。

CORS分：简单请求和非简单请求

一般简单请求只有 HEAD GET POST，并且HTTP的头信息不超过几个字段

```
Accept
Accept-Language
Content-Language
Last-Event-ID
Content-Type
```

除以上情况外，则为非简单请求。

简单请求的基本流程流程：

浏览器会直接发出CORS请求，会在header添加一个Origin字段。服务器根据这个值，决定是否同意这次请求。

如果服务器允许这次请求，会返回一个正常的http回应，并在头信息中带上access controll allow origin 域名。

非简单请求，

非简单请求会对服务有特殊要求的请求，比如请求方法是PUT或Delete，或者请求json数据

非简单请求会在通信之前，增加一次HTTP查询请求，进行一个预检。作用也是询问服务器，当前网页是否在服务器许可名单之中。

除了返回access


与JSONP的比较

CORS与JSONP的使用目的相同，但是比JSONP更强大。

JSONP只支持GET请求，CORS支持所有类型的HTTP请求。JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据。


### http版本


http 0.9需求简单，只能发送简单的超文本

http 1.0

引入请求头和响应头，状态码
提供Cache机制
支持多种格式的资源传输

http 1.1
支持持久连接
每个域名最多同时维护6个TCP持久连接
使用CDN的实现域名分片机制
客户端Cookie机制和安全机制
提供虚拟主机支持，因此增加拉host字段。
对动态生成的内容提供完美支持

不成熟的管线化：

持久连接虽然能减少TCP的建⽴和断开次数，但是它需要等待前⾯的请求返回之后，才能进⾏下⼀次请求。
如果TCP通道中的某个请求因为某些原因没有及时返回，那么就会阻塞后⾯的所有请求，这就是著名的队头
阻塞的问题。

HTTP/1.1中的管线化是指将多个HTTP请求整批
提交给服务器的技术，虽然可以整批发送请求，不过服务器依然需要根据请求顺序来回复浏览器的请求。

缺点：
- TCP慢启动
- 多个TCP连接，竞争固定的带宽
- 队头阻塞

http2.0
- 多路复用：实现资源的并⾏请求，任何时候都可以将请求发送给服务器，⽽并不需要等待其他请求的完成，然后服务器也可以随时返回处理好的请求资源给浏览器。
- 可以设置请求的优先级
- 服务器推送
- 头部压缩

多路复⽤的实现：
- 浏览器准备好请求数据，包括了请求⾏、请求头等信息，如果是POST⽅法，那么还要有请求体。
- 这些数据经过⼆进制分帧层处理之后，会被转换为⼀个个带有请求ID编号的帧，通过协议栈将这些帧发送给服务器。
- 服务器接收到所有帧之后，会将所有相同ID的帧合并为⼀条完整的请求信息。

有了⼆进制分帧层还能够实现请求的优先级、服务器推送、头部压缩等特性，从⽽⼤
⼤提升了⽂件传输效率。