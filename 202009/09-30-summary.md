## 2020-09-30

### 什么是闭包？

要理解闭包，需要结合作用域链来理解。

在每个执行上下文的变量环境中，都包含着一个外部引用，用来指向外部的执行上下文，可以把这个外部引用叫outer

例如在全局执行上下文声明了一个变量和一个函数，而这个函数在内部对这个变量进行了输出。

当函数调用时时，JavaScript引擎⾸先会在“当前的执⾏上下⽂”中查找该变量，如果在当前的变量环境中没有查找到，那么JavaScript引擎会继续在outer所指向的执⾏上下⽂中查找。

这个查找的链条就称为作⽤域链。

而作⽤域链又是由词法作⽤域决定的。

**词法作⽤域就是指作⽤域是由代码中函数声明的位置来决定的**

正如我刚刚举的例子，在全局作用域声明了一个函数，那词法作⽤域链查找顺序就是：函数的作用域再到全局作用域。

如果理解了以上概念，再来理解闭包容易多。

再举一个例子，在全局声明了一个函数，暂且叫它外部函数，而在这个外部函数内，又声明了一个内部函数，同时这个内部函数还输出了外部声明的一个变量，在外部函数的最后，把这个内部函数return出去。

在JavaScript中，根据词法作⽤域的规则，内部函数总是可以访问其外部函数中声明的变量，当通过调⽤⼀个外部函数返回⼀个内部函数后，即使该外部函数已
经执⾏结束了，但是内部函数引⽤外部函数的变量依然保存在内存中，我们就把这些变量的集合称为闭包。

而这次的查找顺序是：当前执行上下文，再到外部函数的闭包，最后到全局执行上下文。

闭包回收：
- 如果引⽤闭包的函数是⼀个全局变量，那么闭包会⼀直存在直到⻚⾯关闭；但如果这个闭包以后不再使⽤的话，就会造成内存泄漏。
- 如果引⽤闭包的函数是个局部变量，等函数销毁后，在下次JavaScript引擎执⾏垃圾回收时，判断闭包这块内容如果已经不再被使⽤了，那么JavaScript引擎的垃圾回收器就会回收这块内存。
---
### 通用组件处理

一般组件可以分为业务组件和UI组件

UI组件一般也称为基础组件，由于基础组件一般不会耦合业务逻辑，页面会需要经常调用。所以会使用业内比较出名的框架，例如Vuetify、专为移动端设计的vant框架，这样可以大大节省开发效率。

而业务组件可能会涉及比较复杂的功能设计，需要结合产品功能设计来进行抽离复用。

对于交互简单的，例如一些站内的弹框，不需要与其他组件进行交互，一般会把结果，样式及交互逻辑，都封装在一个组件内。这样需要展示组件的页面直接引入组件即可。

对于稍微复杂的业务组件，为了逻辑清晰，可以规定，展示的数据只能从父组件传入子组件，并且事件绑定在父组件上。

对于有特殊场景的需求，可以在组件中预留slot。

---
### vue中watch和computed的区别

computed的定义是计算属性，它会根据依赖的数据动态的显示新的结果。计算结果会被缓存，computed的值在getter执行后是会缓存的，只有在它依赖的属性值改变之后，下一次获取computed的值才会重新调用对应的getter来计算。

computed可以和methods定义方法返回值比较，如果页面中有多个位置调用computed的属性值，那computed只会执行一次，而用methods定义的返回值则会每个地方都会执行一次。

而watcher更像是一个data的数据监听回调。当依赖的data的数据发生变化后并执行相应的回调，回调函数接收newVal和oldVal。

总结一下使用场景就是，两者都会依赖数据的变化，computed更多的用在数据组装或者模板中使用复杂逻辑运算。例如可能是两个字段拼接。

而watcher是监听某个数据发生变化，并且我们需要进行一些其他操作，例如执行异步操作。

---

### Vue如何自定义指令

可以通过Vue.directives方法来注册，Vue.directives定义了几个钩子函数来扩展功能，表示自定义的需要哪个几个阶段触发

我记得有bind，inserted、update、computedUpdated，

bind，只调用一次，绑定时就会触发

inserted，是元素被插入到DOM时触发

update，是指令所在元素更新时触发

computedUpdate，指令所在组件或者子组件更新时触发

unbind，解除绑定时触发

钩子函数会接收4个参数，el和binding，vnode，oldVnode

el是我们当前绑定的元素

binding是传入到指令中的一些配置信息

vnode是当前元素的虚拟节点

oldVnode是上一次的虚拟节点，仅在updated和componentUpdated可用

我自己想到一个场景，可能是产品同事需要在网站埋很多的点，以此来了解用户的点击量，如果一个一个元素的绑定click事件，可能会非常麻烦

所以可以自己定义一套执行规则，自定义一个埋点指令。

如何移除事件绑定，可以通过定义一个全局map，把声明事件回调，按元素保存起来，接着在unbind的时候再进行移除

dataset

---

### Vue常见性能优化

- 函数式组件

  函数式组件和普通的对象类型的组件不同，它不会被看作成一个真正的组件，我们知道在 patch 过程中，如果遇到一个节点是组件 vnode，会递归执行子组件的初始化过程；而函数式组件的 render 生成的是普通的 vnode，不会有递归子组件的过程，因此渲染开销会低很多

  函数式组件也不会有状态，不会有响应式数据，生命周期钩子函数这些东西。

  优化前：
  ```vue
  <template>
    <div class="cell">
      <div v-if="value" class="on"></div>
      <section v-else class="off"></section>
    </div>
  </template>

  <script>
  export default {
    props: ['value'],
  }
  </script>
  ```

  优化后：
  ```vue
  
  <template functional>
    <div class="cell">
      <div v-if="props.value" class="on"></div>
      <section v-else class="off"></section>
    </div>
  </template>
  ```

- 合理使用computed

- v-if 和 v-show

- keepAlive：对于需要频繁进行组件切换的，可以用组件缓存DOM，下次缓存的时候就不会重复渲染直接读取缓存

- 虚拟列表优化：https://cloud.tencent.com/developer/article/1533206
---
### computed的基本原理

![https://segmentfault.com/img/bVbFbA5](https://segmentfault.com/img/bVbFbA5)

![https://segmentfault.com/img/bVbFbtt](https://segmentfault.com/img/bVbFbtt)


可以从三个方便解答这个：

1、computed的初始化，初始化做了什么事情

2、data属性发生变化后，computed会重新计算，是如何实现的

3、computed是如何缓存值的，并如何读取缓存值


https://segmentfault.com/a/1190000022169550
---
### vue $set函数

由于Javascript的限制，Vue不能检测数组和对象的变化，所以才会有Vue set方法

可以分别从对象或数组来讲解，

对于对象

Vue 会在初始化实例时对 property 执行 getter/setter 转化，所以 property 必须在 data 对象上存在才能让 Vue 将它转换为响应式的。因此对新添加或者移除属性是无法检测的。

对于已经创建的实例，Vue 不允许动态添加根级别的响应式 property。但是，可以使用 Vue.set(object, propertyName, value) 方法向嵌套对象添加响应式 property。会接收三个参照，第一个就是vue实例上的嵌套对象，第二个是新增的属性名，第三个是属性值

而对于嵌套对象有多个属性新增的情况，可以先用Object.assign方法先进行合并，再重新赋值给嵌套对象。


而对于数组

1、当你利用索引直接设置一个数组项时
2、当你修改数组的长度时

修改数组长度的情况比较少，主要还是第一种情况比较多

有两种解决方案：

第一种还是使用vue set，这次是传入需要修改的数组，第二个参数是索引，以及第三个参数是需要修改的值

第二种方法是利用调用数组的splice方法，对原来索引位置的值进行替换。实际上，源码也是这样调用

具体原理就是

如果判断是数组，就调用splice方法进行替换。

如果是对象属性，则重新调用defineReactive，转换为响应式对象，并且调用dep.notify触发更新视图。


---
### vuex 原理

Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则管理和操作数据。

例如state用于存储组件中的数据，action用于异步操作，整合多个 mutations，而state的更新只能通过mutations来操作。

具体的原理是：通过vue的插件机制，在vue的生命周期beforeCreated钩子函数执行时，在全局注入vuex的store对象，实现状态共享。

### v-model原理

### 获取数据是在created做好，还是在mounted里做


### 原型和原型链

在javascript中，不像其他语言一样有类的概念，Javascript只有一种结构，就是对象。所以在很久之前就这么一句话，在JS中一切皆对象。

而每个函数默认都有一个显示prototype的属性，这个属性同时还会指向一个对象，这个就是我们的原型对象

当我们用构造函数来new一个实例对象，这个实例对象会有一个隐式的__proto__属性，同时这个属性又指向了构造函数prototype的原型对象。

但刚刚提到原型对象，也有一个隐式的__proto__，也指向一个原型对象，就这样层层向上直到一个对象的原型对象为null，而这样的链子就是所谓的原型链。

而原型链可以帮助我们实现共享属性，当我们创建一个了一个实例对象，并尝试访问该对象上一个属性时，如果该对象存在访问的属性，则会直接返回。如果实例对象不存在该属性，js引擎就会沿着原型链继续查找，

找到了就直接返回，找不到会返回undefined

---
### 继承

- 原型继承

```js
function Person() {}

function Child() {}

Child.prototype = new Person() {}
```

缺点是：
  - 父类引用类型的属性被所有子类实例共享，如果其中一个子类修改了父类的属性，其它子类也会受到影响
  - 创建子类实例时，不能对父类传参数

- 构造函数继承

```js
function Person(name) {
  this.name = name
}

function Child(name) {
  Person.call(this, name)
}
```

优点：
  - 避免了引用类型的属性被所有实例共享，这也会造成额外的一部分开销
  - 可以在子类中向父类传参

缺点：无法继承父类原型上的方法和属性

- 组合继承：即原型继承 + 构造函数继承

```js
function Animal() {}

Animal.prototype.greet = function() {
  console.log('hello')
}

function Dog() {
  Animal.call(this, arguments)
}

Dog.prototype = new Animal()
```
优点：融合原型链继承和构造函数的优点，是 JavaScript 中最常用的继承模式

缺点是，会调用两次父类的构造函数

- 原型式继承：相当于Object.create的模拟实现，需要传入一个对象作为即将创建的对象的原型

```js
function createObject(o) {
  function F() {}
  F.prototype = o
  return new F()
}
```

缺点：包含引用类型的属性值始终都会共享相应的值，这点跟原型链继承一样。

- 寄生组合继承：由于组合继承的两次调用父类构造函数，所以寄生组合的关键是减少一次父类构造函数调用，

  具体的操作就是，再创建一个空的构造函数，并把这个空的构造函数的原型执行父类的构造函数

  再用原型继承，子类的原型继承这个空的构造函数的实例，不过子类原型的contructor会被改掉，可以重新赋值为子类的构造函数

  ```js
  function Parent (name) {
    this.name = name;
    this.colors = ['red', 'blue', 'green'];
  }

  Parent.prototype.getName = function () {
      console.log(this.name)
  }

  function Child (name, age) {
      Parent.call(this, name);
      this.age = age;
  }

  // 关键的三步
  var F = function () {};

  F.prototype = Parent.prototype;

  Child.prototype = new F();
  Child.prototype.contructor = Child

  var child1 = new Child('kevin', '18');

  console.log(child1);
  ```

- extends继承：仅仅是一个语法糖，底层还是通过原型继承
---

### diff算法

diff算法是基于同层级进行比较

如果不是同一节点，会插入新的节点，把旧的节点删除

如果是同一节点，调用 patchVnode()，找节点的差异并更新 DOM

核心的diff算法是updateChildren

在进行同级别节点比较的时候，首先会对新老节点数组的开始和结尾节点设置标记索引，遍历的过程中移动索引

在对开始和结束节点比较的时候，总共有四种情况：

- 旧开始节点 / 新开始节点
- 旧结束节点 / 新结束节点
- 旧开始节点 / 新结束节点
- 旧结束节点 / 新结束节点
---

### 常见攻击 XSS和 CSRF

XSS，即跨站脚本。指的是黑客往HTML文件中或DOM注入恶意脚本，从而在用户浏览页面时利用注入的恶意脚本对用户实施攻击的手段。

恶意脚本可以：窃取Cookie信息，监听用户行为，修改DOM，以及在页面内生成浮窗广告。

常见注入方式：存储型XSS攻击，反射型XSS攻击和基于DOM的XSS攻击（恶意软件劫持）

前两种攻击方式都是利用网站漏洞，

如何预防：
- 服务器对输入脚本进行过滤或转码
- 充分利用CSP：CSP的核⼼思想是让服务器决定浏览器能够加载哪些资源，让服务器决定浏览器是否能够执⾏内联JavaScript代码
  - 限制加载其它域的脚本
  - 禁止向第三方域提交数据
  - 禁止执行内联脚本和未授权的脚本
- 利用httpOnly属性，服务器可以将某些Cookie设置为HttpOnly标志，使⽤HttpOnly标记的Cookie只能使⽤在HTTP请求过程中，所以⽆法通过JavaScript来读取这段Cookie

接着介绍一下CSRF，即跨站请求伪造。指⿊客引诱⽤⼾打开⿊客的⽹站，在⿊客的⽹站中，利⽤⽤⼾的登录状态发起的跨站请求。

有两个关键就是服务器存在漏洞并且用户已登录网站

如何预防：
- 充分利用好Cookie的SameSite属性，从第三方站点发送请求是禁止Cookie的发送
- 验证请求的来源站点 http请求头中的Referer和Origin属性。
- CSRF Token验证。

切记陌生的链接不要点。
---
### https的加密原理

https加密是在http和TCP之间多加了一层安全层，对发起HTTP请求的数据进行加密操作和对接收的http内容进行解密操作。加密的版本有多种，有对称加密和非对称加密

对称加密简单的理解就是浏览器和服务端加密和解密的秘钥是一样的。

所以在发送数据之前，需要协商加解密的方式，这也是https建立安全连接的过程。

具体过程是：
- 浏览器向浏览器发送它所支持的加密套件列表和一个随机数client-random
- 服务器从加密套件列表中选取一个加密套件，然后还会生成一个随机数service-random，并把加密套件和service-random返回给浏览器
- 接着浏览器和服务器分别返回确认信息
- 最后浏览器和服务器通过使用相同的方法将client-random和service-random混合起来生成密钥mater secret，有了密钥和加密套件，双方就可以进行数据加密传输了

缺点是：传输client-random和service-random的过程却是明⽂的，黑客也可以拿到协商的加密套件和双方的随机数，由于加密算法是公开的，这样黑客就可以自己合成密钥，用来破解数据，并进行伪造或篡改数据。

第二种方式使用非对称加密
---

### 跨域资源共享CORS

CORS是一个W3C标准，全称为跨域资源共享

它允许浏览器向跨域源服务器，发起XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。

CORS分：简单请求和非简单请求

一般简单请求只有 HEAD GET POST，并且HTTP的头信息不超过几个字段

```
Accept
Accept-Language
Content-Language
Last-Event-ID
Content-Type
```

除以上情况外，则为非简单请求。

简单请求的基本流程流程：

浏览器会直接发出CORS请求，会在header添加一个Origin字段。服务器根据这个值，决定是否同意这次请求。

如果服务器允许这次请求，会返回一个正常的http回应，并在头信息中带上access controll allow origin 域名。

非简单请求，

非简单请求会对服务有特殊要求的请求，比如请求方法是PUT或Delete，或者请求json数据

非简单请求会在通信之前，增加一次HTTP查询请求，进行一个预检。作用也是询问服务器，当前网页是否在服务器许可名单之中。

除了返回access


与JSONP的比较

CORS与JSONP的使用目的相同，但是比JSONP更强大。

JSONP只支持GET请求，CORS支持所有类型的HTTP请求。JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据。


### http版本


http 0.9需求简单，只能发送简单的超文本

http 1.0

引入请求头和响应头，状态码
提供Cache机制
支持多种格式的资源传输

http 1.1
支持持久连接
每个域名最多同时维护6个TCP持久连接
使用CDN的实现域名分片机制
客户端Cookie机制和安全机制
提供虚拟主机支持，因此增加拉host字段。
对动态生成的内容提供完美支持

不成熟的管线化：

持久连接虽然能减少TCP的建⽴和断开次数，但是它需要等待前⾯的请求返回之后，才能进⾏下⼀次请求。
如果TCP通道中的某个请求因为某些原因没有及时返回，那么就会阻塞后⾯的所有请求，这就是著名的队头
阻塞的问题。

HTTP/1.1中的管线化是指将多个HTTP请求整批
提交给服务器的技术，虽然可以整批发送请求，不过服务器依然需要根据请求顺序来回复浏览器的请求。

缺点：
- TCP慢启动
- 多个TCP连接，竞争固定的带宽
- 队头阻塞

http2.0
- 多路复用：实现资源的并⾏请求，任何时候都可以将请求发送给服务器，⽽并不需要等待其他请求的完成，然后服务器也可以随时返回处理好的请求资源给浏览器。
- 可以设置请求的优先级
- 服务器推送
- 头部压缩

多路复⽤的实现：
- 浏览器准备好请求数据，包括了请求⾏、请求头等信息，如果是POST⽅法，那么还要有请求体。
- 这些数据经过⼆进制分帧层处理之后，会被转换为⼀个个带有请求ID编号的帧，通过协议栈将这些帧发送给服务器。
- 服务器接收到所有帧之后，会将所有相同ID的帧合并为⼀条完整的请求信息。

有了⼆进制分帧层还能够实现请求的优先级、服务器推送、头部压缩等特性，从⽽⼤
⼤提升了⽂件传输效率。

### 河东有60万人，河西有40万人，打100万个电话，跨河电话会有多少个？

我们可以化简一下人数，分别是河东：河西 = 3 ：2，

如果打电话的人是河东，那么接电话是河西的概率是1/2，

如果打电话的是河西，那么接电话的时河东的概率是1/4，

两概率相加除以2得3/8，所以概率是3/8， 3/8 * 100万就是最后的人数。


如果打电话的人是河东，那么接电话是河西的概率是1/2，经过简化以后，河东有三个人，河西有两个人，河东有一个人打电话，那么就剩下河东两个人可能会会接电话，河西有两个人可能会接电话，所以跨河电话的概率是1/2，如果打电话的人是河西的，同样的道理。

### 字典序最小问题

给定长度为N(1≤N≤2000)的字符串S，要构造一个长度为N的字符串T。期初，T是一个空串，随后反复进行下列任意操作。
- 从S的头部删除一个字符，加到T的尾部
- 从S的尾部删除一个字符，加到T的尾部

目标是要构造字典序尽可能小的字符串。
https://blog.nowcoder.net/n/325ceab453e244ffbc7d9f91591f4b69
```js
function lexicalOrder(str) {
  const n = str.length
  if (!n) return ''
  
  let a = 0,
      b = n - 1
  
  let ans = ''
  while(a <= b) {
    // 判断取头还是取尾
    let left = false
    
    for(let i = 0; a + i <= b; i++) {
      const first = str.charAt(a + i)
      const last = str.charAt(b - i)
      if (first < last) {
        left = true
        break
      } else if (first > last) {
        left = false
        break
      }
      // 如果头尾相等，则继续判断下一位
    }
    if (left) {
      ans += str.charAt(a)
      a++
    } else {
      ans += str.charAt(b)
      b--
    }
  }
  return ans
}
```

### 找7

包含7及7的倍数

```js
function printSeven(n) {
  if (n < 7) return []
  const res = []
  for(let i = 7; i <= n; i++) {
    // 7的倍数
    if (i % 7 === 0) {
      res.push(i)
      continue
    }
    
    // 遍历判断是否包含数字7
    let tmp = i
    while(tmp) {
      const num = i % 10
      tmp = tmp / 10 | 0
      if (num === 7) {
        res.push(i)
        break
      }
    }
  }
  return res
}
```

### 找出数组中比左边大比右边小的元素

```js
function findMid2(arr) {
  const n = arr.length
  const minArr = new Array(n - 1)
  const ans = []
  
  let min = arr[n - 1]
  for(let i = n - 2; i >= 0; i--) {
    minArr[i] = min
    if (arr[i] < min) {
      min = arr[i]
    }
  }
  
  let max = arr[0]
  for(let i = 1; i < n - 1; i++) {
    if (arr[i] > max) {
      max = arr[i]
      if (arr[i] < minArr[i]) {
        ans.push(arr[i])
      }
    }
  }
  return ans
}
```

### 个税计算

```js
function payTax(salary) {
  const base = 800
  const level = [0, 500, 2000, 5000, 20000, 40000, 60000, 80000, 100000, 100000]
  const ratio = [5, 10, 15, 20, 25, 30, 35, 40, 45]

  const tmp = salary - base
  let tax = 0
  if (tmp > 0) {
    for(let i = 1; i <= level.length; i++) {
      if (tmp > level[i]) {
        tax += (level[i] - level[i - 1]) * ratio[i - 1] / 100
      } else {
        tax += (tmp - level[i - 1]) * ratio[i - 1] / 100
        break
      }
    }
  }
  return tax
}

```

### 进程、线程、协程

可以以浏览器进程来讲吗？

首先讲讲什么是进程

简单的理解，进程就是程序运行时的一个实例，启动一个程序的时候，操作系统会为该程序创建一块内存，用来存放代码、运行中的数据和一个执行任务的主线程，这样的一个运行环境就是进程。

而线程是不能单独存在的，它是由进程来启动和管理的。可以分为单线程和多线程。但往往为了处理复杂的任务，一个进程会有创建多个线程，这样可以赋予进程并行处理的能力。

进程和线程是息息相关的，一般会有几个特点：

例如：
- 进程中的任意一线程执行出错，都会导致整个进程的崩溃
- 线程之间共享进程中的数据
- 当一个进程关闭后，操作系统会回收进程所占用的内存
- 进程之间的内容相互隔离，如果需要进行通信需要使用IPC机制进行通信

最开始浏览器是以单进程来架构的，也就是浏览器所有的功能模块都是运行在同一个进程里，例如网络、插件，javascript运行环境、渲染引擎，页面等。

不稳定、不流畅、不安全

为了解决单进程的缺点，就有了现在浏览器的多进程架构，把浏览器的一些功能模块进行了独立

例如会拆分成浏览器进程、渲染进程、GPU进程、网络进程、插件进程。

#### 进程

一个进程好比是一个程序，它是 资源分配的最小单位 。同一时刻执行的进程数不会超过核心数。不过如果问单核CPU能否运行多进程？答案又是肯定的。单核CPU也可以运行多进程，只不过不是同时的，而是极快地在进程间来回切换实现的多进程。举个简单的例子，就算是十年前的单核CPU的电脑，也可以聊QQ的同时看视频。

电脑中有许多进程需要处于「同时」开启的状态，而利用CPU在进程间的快速切换，可以实现「同时」运行多个程序。而进程切换则意味着需要保留进程切换前的状态，以备切换回去的时候能够继续接着工作。所以进程拥有自己的地址空间，全局变量，文件描述符，各种硬件等等资源。操作系统通过调度CPU去执行进程的记录、回复、切换等等。

### 线程

如果说进程和进程之间相当于程序与程序之间的关系，那么线程与线程之间就相当于程序内的任务和任务之间的关系。所以线程是依赖于进程的，也称为 「微进程」 。它是 程序执行过程中的最小单元 。

一个程序内包含了多种任务。打个比方，用播放器看视频的时候，视频输出的画面和声音可以认为是两种任务。当你拖动进度条的时候又触发了另外一种任务。拖动进度条会导致画面和声音都发生变化，如果进程里没有线程的话，那么可能发生的情况就是：

拖动进度条->画面更新->声音更新。你会明显感到画面和声音和进度条不同步。

但是加上了线程之后，线程能够共享进程的大部分资源，并参与CPU的调度。意味着它能够在进程间进行切换，实现「并发」，从而反馈到使用上就是拖动进度条的同时，画面和声音都同步了。所以我们经常能听到的一个词是「多线程」，就是把一个程序分成多个任务去跑，让任务更快处理。不过线程和线程之间由于某些资源是独占的，会导致锁的问题。例如Python的GIL多线程锁。

### 并发与并行

并发：在操作系统中，某一时间段，几个程序在同一个CPU上运行，但在任意一个时间点上，只有一个程序在CPU上运行。

当有多个线程时，如果系统只有一个CPU，那么CPU不可能真正同时进行多个线程，CPU的运行时间会被划分成若干个时间段，每个时间段分配给各个线程去执行，一个时间段里某个线程运行时，其他线程处于挂起状态，这就是并发。并发解决了程序排队等待的问题，如果一个程序发生阻塞，其他程序仍然可以正常执行。

并行：当操作系统有多个CPU时，一个CPU处理A线程，另一个CPU处理B线程，两个线程互相不抢占CPU资源，可以同时进行，这种方式成为并行。

区别

并发只是在宏观上给人感觉有多个程序在同时运行，但在实际的单CPU系统中，每一时刻只有一个程序在运行，微观上这些程序是分时交替执行。
在多CPU系统中，将这些并发执行的程序分配到不同的CPU上处理，每个CPU用来处理一个程序，这样多个程序便可以实现同时执行。
知乎上高赞例子：

你吃饭吃到一半，电话来了，你一直到吃完了以后才去接，这就说明你不支持并发也不支持并行。
你吃饭吃到一半，电话来了，你停了下来接了电话，接完后继续吃饭，这说明你支持并发。
你吃饭吃到一半，电话来了，你一边打电话一边吃饭，这说明你支持并行。
并发的关键是你有处理多个任务的能力，不一定要同时。并行的关键是你有同时处理多个任务的能力。所以我认为它们最关键的点就是：是否是『同时』。

### 死锁

死锁一般在多进程环境出现的。

如果有两个或两个以上的进程为竞争统一资源而出现等待的现象。

一般来说死锁的出现必须满足以下四个必要条件：
- **互斥条件**：指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放。
- **请求和保持条件**：指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放。
- **不剥夺条件**：指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。
- **环路等待条件**：指在发生死锁时，必然存在一个进程——资源的环形链，即进程集合{P0，P1，P2，···，Pn}中的P0正在等待一个P1占用的资源；P1正在等待P2占用的资源，……，Pn正在等待已被P0占用的资源。
要避免出现死锁的问题，只需要破坏四个条件中的任何一个就可以了。

破坏死锁：
- 破坏互斥：可以拷贝多个资源的副本，成本较大，不适用
- 破坏环路等待：可以规定获取资源的顺序，
- 破坏不剥夺：可以设置资源最长占用时间，就释放资源。重启
- 破坏请求和保持条件：再获取新的资源前，必须释放占用的资源
https://zhuanlan.zhihu.com/p/26945588

死锁避免
- 单个资源的银行家算法：银行家算法就是对每个请求进行检查，检查是否请求会引起不安全状态，如果不会引起，那么就接受该请求；如果会引起，那么就推迟该请求。
---
### 进程调度

- 先来先服务调度算法：当在**作业调度**中采用该算法时，每次调度都是从后备作业队列中选择一个或多个最先进入该队列的作业，将它们调入内存，为它们分配资源、创建进程，然后放入就绪队列。在**进程调度**中采用FCFS算法时，则每次调度是从就绪队列中选择一个最先进入该队列的进程，为之分配处理机，使之投入运行。该进程一直运行到完成或发生某事件而阻塞后才放弃处理机。

- 短作业(进程)优先调度算法：短作业优先(SJF)的调度算法是从后备队列中选择一个或若干个估计运行时间最短的作业，将它们调入内存运行。而短进程优先(SPF)调度算法则是从就绪队列中选出一个估计运行时间最短的进程，将处理机分配给它，使它立即执行并一直执行到完成，或发生某事件而被阻塞放弃处理机时再重新调度。

- 时间片轮转法：在先来先服务的基础上加入时间片，时间片的大小从几ms到几百ms，当执行的时间片用完时，由一个计时器发出时钟中断请求，调度程序便据此信号来停止该进程的执行，并将它送往就绪队列的末尾；然后，再把处理机分配给就绪队列中新的队首进程，同时也让它执行一个时间片。

- 优先权调度算法：也就是会把资源分配给优先权最高的进程。
  - 非抢占式优先权算法
  - 抢占式优先权调度算法
- 多级反馈队列调度算法：被公认的一种较好的进程调度算法，设置多个就绪队列，同时设置每个队列的优先级并且配有不同的时间片，一般优先权越高的队列，时间片会越小，

https://blog.csdn.net/fuzhongmin05/article/details/55802925
### 同步异步

#### 阻塞与非阻塞

阻塞是指调用线程或者进程被操作系统挂起。
非阻塞是指调用线程或者进程不会被操作系统挂起。


#### 同步与异步

同步是阻塞模式，异步是非阻塞模式。

- 同步就是指一个进程在执行某个请求的时候，若该请求需要一段时间才能返回信息，那么这个进程将会一直等待下去，知道收到返回信息才继续执行下去；
- 异步是指进程不需要一直等下去，而是继续执行下面的操作，不管其他进程的状态。当有消息返回式系统会通知进程进行处理，这样可以提高执行的效率。

### TCP / UDP

UDP简称用户数据包协议，UDP中一个重要的信息是端口号，每个想访问网络的程序都需要绑定一个端口，通过端口号UDP就能把指定的数据包发送给指定的程序。

UDP可以校验数据是否正确，但是对于错误的数据包，UDP并不提供重发机制，只会丢弃当前的包，而且UDP在发送之后，也无法知道是否能到达目的地。

虽说UDP不能保证数据可靠性，但是传输速度非常快。一般用在数据不那么严格的领域，如在线视频，互动游戏等。

而TCP是一种面向连接的、可靠的、基于字节流的传输层通信协议。

### IOS 7层架构


### 设计ROOM和USER

如果要实现一个聊天室的逻辑，有room和user两个类，而room设置有一个门，而且有“主人的设定，只有主人才能开门和关门。请问开门和关门的方法，你会放到room类还是user类中实现 ？为什么？下图的两种实现方法，哪个更好？

第一直觉，门是 room上的一个属性， 门有开和关的状态，room提供修改门状态的方法，但是这里需要有一个认证信息，即可能有多个房间，每个房间所属的user可能不一样。所以再操作开门需要有一个鉴权。

### 洗牌算法

随机算法

```js
// https://segmentfault.com/a/1190000002972940
function shuffle(arr) {
  const randRange = (min, max) => {
    // [min, max]
    // return Math.floor(Math.random() * (max - min + 1)) + min
    // [min, max)
    return Math.floor(Math.random() * (max - min)) + min
  }

  const swap = (i, j) => {
    const tmp = arr[i]
    arr[i] = arr[j]
    arr[j] = tmp
  }

  const n = arr.length
  for(let i = 0; i < n; i++) {
    swap(i, randRange(i, n))
  }
  console.log(arr)
}

shuffle([])
```

###  一家3个孩子，已知一个男孩，剩下至少有一个女孩的概率

直接穷举

可能的情况如下：男男、男女、女男、女女

所以至少有一个女孩的概率 四分之三

### 随机数生成器

 随机数生成器，只生成0，1，但是不公平，做一个公平的方案？

 假设生成0的概率60%，生成1的概率是40%

 可以用01代表0， 10代表1，其它情况重新进行

 ```js
 var rand_0_1 = function() {
  const randRange = () => {
    return Math.floor(Math.random() * 2)
  }
  while(true) {
    const num1 = randRange()
    const num2 = randRange()
    if (num1 === 0 && num2 === 1) {
      return 0
    } else if (num1 === 1 && num2 === 0) {
      return 1
    }
  }
}
 ```

### 给个数字n，0到n每个数字的二进制的1的个数
对于所有的数字，只有两类：

奇数：二进制表示中，奇数一定比前面那个偶数多一个 1，因为多的就是最低位的 1。
```
          举例： 
         0 = 0       1 = 1
         2 = 10      3 = 11
```         
偶数：二进制表示中，偶数中 1 的个数一定和除以 2 之后的那个数一样多。因为最低位是 0，除以 2 就是右移一位，也就是把那个 0 抹掉而已，所以 1 的个数是不变的。
```           
           举例：
          2 = 10       4 = 100       8 = 1000
          3 = 11       6 = 110       12 = 1100
```          
另外，0 的 1 个数为 0，于是就可以根据奇偶性开始遍历计算了。

https://leetcode-cn.com/problems/counting-bits/solution/hen-qing-xi-de-si-lu-by-duadua/
```js
function countBits(n) {
  const ans = new Array(n + 1).fill(0)

  for(let i = 1; i <= n; i++) {
    ans[i] = i & 1 === 1 ? ans[i - 1] + 1 : ans[i / 2]
  }
  return ans
}
```

### 判断二叉树是否是镜像对称的，只需要返回true或false就行

```js
function isSymmetic(root) {
  if (!root) return true

  const rec = (l, r) => {
    if (!l && !r) return true
    if (l && r && l.val === r.val && rec(l.left, r.right) && rec(l.right, r.left)) {
      return true
    } else {
      return false
    }
  }
  return rec(root.left, root.right)
}
```

### 大医院每天接生100人，小医院每天接生50人，哪个医院能达到“生男孩几率大于60%”的目标的多一点？

https://www.zhihu.com/question/265031808

第一直觉，小医院，大数定律，样本越多频率越接近概率

解法一：

大医院每天生2个,小医院每天生1个

大医院只有0.25(四种情况中的一种)的机会大于60%.

小医院有0.5的机会大于60%

解法二：


### 跨域

浏览器由于安全问题，会有一个同源策略，简单的理解如果请求的协议、域名、端口，三者之一有不同的话，浏览器会禁止请求。

一般来说，可以分几种情况：
- 如果只是简单的资源加载，可以使用图片和script标签，来加载其它域的资源
- 如果是API跨域请求可以有以下几种方案：
  - 第一种是jsonp，也是利用script可以跨域加载资源，我们可以在当前页面声明全局的函数，然后再服务端封装函数返回并执行
  - 第二种是CORS，跨资源请求限制，在服务端设置可以访问的域
  - 第三种是在ngix设置反向代理，在服务端设置转发的api
  - 其它方式，可能还有websocket以及window.postMessage api

  不过以上方案，最终都需要对方域名设置可访问才能进行。所以需要设置好服务端配置。


### 优化项目速度

可以从两个方面着手：
- 优化构建速度
- 优化产出的代码

优化构建速度：
- 可以开启babel-loader的缓存功能，例如我们开发项目的时候，写了很多ES6的代码，但是很多都是已经编译过的，我们只需要编译我们有改动的功能，可以开启babel-loader的cacheDirectory功能，对已编译的代码进行缓存
- ignorePlugin和noParse，可以忽略某些插件的打包
- happyPack开启多进程打包
- paralluglifyplugin开启多进程压缩js
- 使用DLLplugin，对一些动态库进行

优化产出的代码：
- 常见前端性能优化，合并压缩文件，提取公共代码
- 小图转base64
- 大文件可以进行懒加载
- 使用CDN
- 配合webpack的scopehosting和tree shaking


后端可以提高服务器性能，增加接口缓存

网络升级http版本


### 判断两个区间有无交集

https://blog.csdn.net/mrwangweijin/article/details/76302778

正向思维 和 逆向思维

正向思维列举有交集的情况，比较麻烦容易漏

逆向思维求没有交集的情况，其余情况就是有交集

### 足够多的水和两个水杯（7L和17L），如何得到9L的水

- 设7L的水杯A，17L的水杯B
- A倒满，并倒入B中，B水为7l,剩余10l容量
- A倒满，并倒入B中，B水为14l，剩余3l容量
- A倒满，并倒入B中，A剩余4l，B满了，并倒掉，把A剩余的水倒入B中，B水为4l，B剩余13L容量
- A倒满，并倒入B中，B水为11l，剩余6l容量
- A倒满，并倒入B中，A剩余1l，B满了，并倒掉，把A剩余的水倒入B中，B水为1l，B剩余16l容量
- A倒满，并倒入B中，B水为8l，剩余9l容量
- A倒满，并倒入B中，B水为15l，剩余2l容量
- A倒满，并倒入B中，A剩余5l，B满了，并倒掉，把A剩余的水倒入B中，B水为5l，B剩余12l容量
- A倒满，并倒入B中，B水为12l，剩余5l容量
- A倒满，并倒入B中，A剩余2l，B满了，倒掉，把A剩余水倒入B中，B为2l
- A倒入b，9l水

### 16个球，有一个异常球，有一个天平秤

3次，

### 




